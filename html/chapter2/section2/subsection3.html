<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>2.2.3 
        Sequences as Conventional Interfaces
      </a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SECTION'><SUBSECTION>

      
      
      

      <div class='permalink'>
<a name='p1' class='permalink'></a><p>
        In working with compound data, we've stressed how data abstraction
        permits us to design programs without becoming enmeshed in the details
        of data representations, and how abstraction preserves for us the
        flexibility to experiment with alternative representations.  In this
        section, we introduce another powerful design principle for working
        with data structuresâ€”the use of <EM>conventional interfaces</EM>.
      </p></div>

      <div class='permalink'>
<a name='p2' class='permalink'></a><p>
        In section~\ref{sec:higher-order-procedures} we saw how program
        abstractions, implemented as higher-order
        functions, can capture
        common patterns in programs that deal with numerical data.  Our
        ability to formulate analogous operations for working with compound
        data depends crucially on the style in which we manipulate our data
        structures.  Consider, for example, the following
        function, analogous
        to the {\lstinline[mathescape=true]$count_leaves$}
        function
        of section~\ref{sec:trees}, which
        takes a tree as argument and computes the sum of the squares of the
        leaves that are odd:

        

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sum_odd_squares(tree) {
    return is_null(tree)
           ? 0
           : ! is_pair(tree)
             ? (is_odd(tree) ? square(tree) : 0)
             : sum_odd_squares(head(tree))
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZxAWwPpwCbY8gRxAEMAnAU2QAooLyBKRAbwChF3EKoRSkZkMYEABthNOvTYdpHAPyIADFJnSAXIgCEifhgAOxGKXHkGyldPlUdObMYaJ5hEhTuN1CyeZXrUmG-iIySioAC3JiW1oTek8vFQBqMzj2XyxcAOdgqAMxKIZ6AG4WAF8gA}{\usebox\lstbox}!*/
               +
               sum_odd_squares(tail(tree));
}

\end{JavaScriptClickable}



        
      </p></div>

      <div class='permalink'>
<a name='p3' class='permalink'></a><p>
        On the surface, this
        function
        is very different from the following
        one, which constructs a list of all the even Fibonacci numbers
        ${\textrm{Fib}}(k)$, where $k$ is less than or equal to a given integer $n$:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function even_fibs(n) {
    function next(k) {
        if (k > n) {
            return null;
        } else {
            const f = fib(k);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAUwG7LAfWDARgZwAowBKRAbwChEbFRJYFExkAPKQgazKtr8RjBEXRAD5mPav2kAnZFBAykYEABtVAbinSAvilX5kFbdNoQE+KHUQBeOni4ktp-nIVKB+TGgyFgJExdTAH5EAAcAQxgZPwAaZjYOTkQAakQARhIAoJyALgT2ETTM51MdE3K+N0VlRMIABidKHSA}{\usebox\lstbox}!*/
            return is_even(f)
                   ? pair(f, next(k + 1))
                   : next(k + 1);
        }
    }
    return next(0);
}

\end{JavaScriptClickable}



        

      </p></div>

      <div class='permalink'>
<a name='p4' class='permalink'></a><p>
        Despite the fact that these two
        functions
        are structurally very
        different, a more abstract description of the two computations reveals
        a great deal of similarity.  The first program
        <UL>
          <LI>enumerates the leaves of a tree;
          </LI>
          <LI>filters them, selecting the odd ones;
          </LI>
          <LI>squares each of the selected ones; and
          </LI>
          <LI>accumulates the results using {\lstinline[mathescape=true]$+$}, starting with 0.
          </LI>
        </UL>
      </p></div>

      <div class='permalink'>
<a name='p5' class='permalink'></a><p>
        The second program
        <UL>
          <LI>enumerates the integers from 0 to $n$;
          </LI>
          <LI>computes the Fibonacci number for each integer;
          </LI>
          <LI>filters them, selecting the even ones; and
          </LI>
          <LI>accumulates the results using {\lstinline[mathescape=true]$pair$},  starting with the
            empty list.
          </LI>
        </UL>
      </p></div>

      <div class='permalink'>
<a name='p6' class='permalink'></a><p>
        
        
        A signal-processing engineer would find it natural to conceptualize
        these processes in terms of signals flowing through a cascade of
        stages, each of which implements part of the program plan, as shown in
        Figure~\ref{fig:signal-flow-plans}.  In {\lstinline[mathescape=true]$sum_odd_squares$}, we
        begin with an 
        
        <EM>enumerator</EM>, which generates a <QUOTE>signal</QUOTE>
        consisting of the leaves of a given tree.  This signal is passed
        through a 
        
        <EM>filter</EM>, which eliminates all but the odd elements.
        The resulting signal is in turn passed through a 
        
        <EM>map</EM>, which is a
        <QUOTE>transducer</QUOTE> that applies the {\lstinline[mathescape=true]$square$}
        function
        to each
        element.  The output of the map is then fed to an 
        
        <EM>accumulator</EM>,
        which combines the elements using {\lstinline[mathescape=true]$+$}, starting from an initial 0.
        The plan for {\lstinline[mathescape=true]$even_fibs$} is analogous.

	<SPLIT>
	  
	  
              
\begin{figure}[H]
\centering

\maxsizebox{\linewidth}{0.8\paperheight}{\includegraphics[scale=0.8]{{img\string_javascript/ch2-Z-G-17}.svg}}
\caption{The signal-flow plans for the
        functions
        {\lstinline[mathescape=true]$sum_odd_squares$} (top) and
	{\lstinline[mathescape=true]$even_fibs$} (bottom) reveal the
        commonality between the two programs.
                }
\label{fig:signal-flow-plans}
\end{figure}

	  
	</SPLIT>
      </p></div>

      <div class='permalink'>
<a name='p7' class='permalink'></a><p>
        Unfortunately, the two
        function
        definitions above fail to exhibit this
        signal-flow structure.  For instance, if we examine the {\lstinline[mathescape=true]$sum_odd_squares$}
        function, we find that the enumeration is
        implemented partly by the {\lstinline[mathescape=true]$is_null$} and {\lstinline[mathescape=true]$is_pair$} tests and partly
        by the tree-recursive structure of the
        function.  Similarly, the
        accumulation is found partly in the tests and partly in the addition used
        in the recursion.  In general, there are no distinct parts of either
        function
        that correspond to the elements in the signal-flow
        description.
        Our two
        functions
        decompose the computations in a different way,
        spreading the enumeration over the program and mingling it with the
        map, the filter, and the accumulation.  If we could organize our
        programs to make the signal-flow structure manifest in the
        functions
        we write, this would increase the conceptual clarity of the resulting
        code.
      </p></div>

      \subsubsection{
        Sequence Operations
      

      
      

      <div class='permalink'>
<a name='p8' class='permalink'></a><p>
        The key to organizing programs so as to more clearly reflect the
        signal-flow structure is to concentrate on the <QUOTE>signals</QUOTE> that flow
        from one stage in the process to the next.  If we represent these
        signals as lists, then we can use list operations to implement the
        processing at each of the stages.  For instance, we can implement the
        mapping stages of the signal-flow diagrams using the {\lstinline[mathescape=true]$map$}
        function
        from section~\ref{sec:sequences}:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
map(square, list(1, 2, 3, 4, 5));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=LYQwDgFAzgjgriATgUwDQAIA2BLKAXCARgwCYMBmDAFgwFYBKegbiA}{\usebox\lstbox}


      </p></div>

      <div class='permalink'>
<a name='p9' class='permalink'></a><p>
        Filtering a sequence to select only those elements that satisfy a
        given predicate is accomplished by
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function filter(predicate, sequence) {
    return is_null(sequence)
           ? null
           : predicate(head(sequence))
             ? pair(head(sequence), 
                    filter(predicate, tail(sequence)))
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABMGAbKBTATgCgA5YYAmMEAhpgDSIDOGAjiBpBgJSIDeAUIr4oVBBYkMGgH0wIVKhx1GzCGx58VfAPyJJ05apUAuRAWKkKGHAAsMZIrIZMWrVjt0qNeMjFyXrt+Q+rOLkHIaJi4RiTkVIhQHjJy9oqOTsH6IejY+ISRptSxaL6JbKwA3FwAvkA}{\usebox\lstbox}!*/
             : filter(predicate, tail(sequence));
}

\end{JavaScriptClickable}



        

      </p></div>

      <div class='permalink'>
<a name='p10' class='permalink'></a><p>
        For example,
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
filter(is_odd, list(1, 2, 3, 4, 5));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYSwNgLgpgTgFCAzgfQPYBN0BoAEYkRwCMuATLgMy4AsuArAJQMDcQA}{\usebox\lstbox}




        Accumulations can be implemented by
        
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function accumulate(op, initial, sequence) {
    return is_null(sequence)
           ? initial
           : op(head(sequence), 
                accumulate(op, initial, tail(sequence)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAQwhEBbEAbZUCmAFHAA4A0iMYMsy2FAzvgI4j6T4CUiA3gFCJBiAE74oIYUhgMA+mBzZCTVuwhcBQzUID8larWwatmgFyJShABb5kAEyUs2HThSPH3qdFlwFi5PTQwdBRQyDCKyk5qnDEA3HwAvkA}{\usebox\lstbox}



        

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
accumulate(plus, 0, list(1, 2, 3, 4, 5));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=IYYxFcFtwG2AXApgCgA43AZwDQAIAMeMAlpvMgIx4BMeAzHgCx4CsAlGwNxA}{\usebox\lstbox}



        


        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
accumulate(times, 1, list(1, 2, 3, 4, 5));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=IYYxFcFtwG2AXApgCngS0ogzgGgAQCM+MaW8yReATPgMz4As+ArAJSsDcQA}{\usebox\lstbox}



        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
accumulate(pair, null, list(1, 2, 3, 4, 5));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=IYYxFcFtwG2AXApgCgA7AJYCcA0ACAO1hnxgwGd5kBGfAJnwGZ8AWfAVgEpOBuIA}{\usebox\lstbox}


      </p></div>

      <div class='permalink'>
<a name='p11' class='permalink'></a><p>
        All that remains to implement signal-flow diagrams is to enumerate the
        sequence of elements to be processed.  For {\lstinline[mathescape=true]$even_fibs$}, we need to
        generate the sequence of
        integers in a given range, which we can do as follows:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function enumerate_interval(low, high) {
    return low > high
           ? null
           : pair(low,
                  enumerate_interval(low + 1, high));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAUzCAtsgTgQysgfRjHywDccAbACkrgHcAaRACxgHMWBKRAbwChEQxFmRQQWJHXqIAfKw4tBwlcID8iNJUrLVKgFyIADjhhZaDRrr02hqDNjyFipCjWmIA1IgCMzNpxcXADc-AC+QA}{\usebox\lstbox}



        
      </p></div>

      <div class='permalink'>
<a name='p12' class='permalink'></a><p>
        To enumerate the leaves of a tree, we can use<a class='superscript' id='footnote-1' href='#footnote-1'>[1]</a>

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function enumerate_tree(tree) {
    return is_null(tree)
           ? null
           : ! is_pair(tree)
             ? list(tree)
             : append(enumerate_tree(head(tree)),
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAUzCAtsgTgQysgfSi2WQApjSBKRAbwChEnESoQskYBnAtAGz4USyKo2bjmAfkT8+YieIBciAISJuBAA44YWIdXkLx0vtyj6Rho02U5Nm1ABMyqDNjyFK5ABbIczryoqABora3DXTFx8ImEKHUFAoIBuegBfIA}{\usebox\lstbox}!*/
                      enumerate_tree(tail(tree)));
}

\end{JavaScriptClickable}



        
      

            

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function enumerate_tree(tree) {
    return is_null(tree)
           ? null
           : ! is_pair(tree)
             ? list(tree)
             : append(enumerate_tree(head(tree)),
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAUzCAtsgTgQysgfSi2WQApjSBKRAbwChEnESoQskYBnAtAGz4USyKo2bjmAfkT8+YieIBciAISJuBAA44YWIdXkLx0vtyj6Rho02U5Nm1ABMyqDNjyFK5ABbIczryoqABora3DXTFx8ImEKHUFAoIBuegBfIA}{\usebox\lstbox}!*/
                      enumerate_tree(tail(tree)));
}

\end{JavaScriptClickable}



        
      </p></div>

      <div class='permalink'>
<a name='p13' class='permalink'></a><p>
        Now we can reformulate {\lstinline[mathescape=true]$sum_odd_squares$} and {\lstinline[mathescape=true]$even_fibs$} as in
        the signal-flow diagrams.  For {\lstinline[mathescape=true]$sum_odd_squares$}, we enumerate the
        sequence of leaves of the tree, filter this to keep only the odd
        numbers in the sequence, square each element, and sum the results:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sum_odd_squares(tree) {
    return accumulate(plus, 
                      0, 
                      map(square, 
                          filter(is_odd, 
                                 enumerate_tree(tree))));
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZxAWwPpwCbY8gRxAEMAnAU2QAooLyBKRAbwChF3EKoRSliII6EABtiUclQAOwkMgA0iNh2UrVHAAwKlanSrTFJVQiQpbd5tcBjDxpKjGRZcZi693kw6cqTHkMtcgkAhnpQgG4WAF8gA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}


      </p></div>

      <div class='permalink'>
<a name='p14' class='permalink'></a><p>
        For {\lstinline[mathescape=true]$even_fibs$}, we enumerate the integers from 0 to $n$, generate
        the Fibonacci number for each of these integers, filter the resulting
        sequence to keep only the even elements, and accumulate the results
        into a list:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function even_fibs(n) {
    return accumulate(pair, 
                      null, 
                      filter(is_even, 
                             map(fib, 
                                 enumerate_interval(0, n))));
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAUwG7LAfWDARgZwAowBKRAbwChEbEAnZKEOpAQwghAFsQAbVqMkIAHVjDoAaRNVqy582mD68pMherk5eguoRj5MaDKo2nTXVsMI5cJs-Y0ZuyOgOSYYYHala9CABilSEhCAbkoAXyA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}


      </p></div>

      <div class='permalink'>
<a name='p15' class='permalink'></a><p>
        The value of expressing programs as sequence operations is that this
        helps us make program designs that are modular, that is, designs that
        are constructed by combining relatively independent pieces.  We can
        encourage modular design by providing a library of standard components
        together with a conventional interface for connecting the components
        in flexible ways.
      </p></div>

      <div class='permalink'>
<a name='p16' class='permalink'></a><p>
        
        
        Modular construction is a powerful strategy for
        controlling complexity in engineering design.  In real
        signal-processing applications, for example, designers regularly build
        systems by cascading elements selected from standardized families of
        filters and transducers.  Similarly, sequence operations provide a
        library of standard program elements that we can mix and match.  For
        instance, we can reuse pieces from the {\lstinline[mathescape=true]$sum_odd_squares$} and {\lstinline[mathescape=true]$even-fibs$}
        functions
        in a program that constructs a list of the
        squares of the first $n+1$ Fibonacci numbers:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function list_fib_squares(n) {
    return accumulate(pair, 
                      null, 
                      map(square, 
                          map(fib, 
                              enumerate_interval(0, n))));
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAGxgZygfWDARptARxAEMAnAUzQAowBKRAbwChE3FKoQykSIIQAWxDISUCtQAOJGGQA0iVu2UrV7MCOQKla3SsElJ1IqUra9FtQaM5c5yw9UUNgimTEVMMMOLIA3EmRqAAYFejoIgG5mAF8gA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}



        
      </p></div>

      <div class='permalink'>
<a name='p17' class='permalink'></a><p>
        We can rearrange the pieces and use them in computing the product of
        the odd integers in a sequence:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function product_of_squares_of_odd_elements(sequence) {
    return accumulate(times, 
                      1, 
                      map(square, 
                          filter(is_odd, sequence)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABABwE5wCYmgfTsHAZwEcQBDVAU0LwMwx0oBtKBbSsKQgCkMtI4RKASkQBvAFCJpiKlBCokZCBBCsQTMlErdY7QgBpEUmabPmZARiMmLds6zLJepCpRv3PF4DCbbU3DA09EZ8ApAiwsIA3BIAvkA}{\usebox\lstbox}



        
      </p></div>

      <div class='permalink'>
<a name='p18' class='permalink'></a><p>
        We can also formulate conventional data-processing applications in
        terms of sequence operations.  Suppose we have a sequence of personnel
        records and we want to find the salary of the highest-paid programmer.
        Assume that we have a selector {\lstinline[mathescape=true]$salary$} that returns the salary of
        a record, and a predicate {\lstinline[mathescape=true]$is_programmer$} that tests if a record is
        for a programmer.  Then we can write
        
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function salary_of_highest_paid_programmer(records) {
    return accumulate(math_max, 
                      0, 
                      map(salary, 
                          filter(is_programmer, records)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZwIYBtUCcCeB9OYPACxgHNiBTZKPAB1RgBN6s4ytUBbLyrACiyUIcLE2QBKRAG8AUIgWIhUEFiSoIEEFxCYolfl1RRieIwA8ANInmK79h4oAM124-f2jdfmky5XHoGOwDDo+gIwyKzsnDx81kIiYpISEgDcsgC+QA}{\usebox\lstbox}


      </p></div>

      <div class='permalink'>
<a name='p19' class='permalink'></a><p>
        These examples give just a hint of the vast range of operations that
        can be expressed as sequence operations.<a class='superscript' id='footnote-2' href='#footnote-2'>[2]</a>
      </p></div>

      <div class='permalink'>
<a name='p20' class='permalink'></a><p>
        Sequences, implemented here as lists, serve
        as a conventional interface that permits us to combine processing
        modules.  Additionally, when we uniformly represent structures as
        sequences, we have localized the data-structure dependencies in our
        programs to a small number of sequence operations.  By changing these, 
        we can experiment with alternative representations of sequences, while
        leaving the overall design of our programs intact.  We will exploit
        this capability in section~\ref{sec:streams}, when we generalize the
        sequence-processing paradigm to admit infinite sequences.
      </p></div>

      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled29}

        Fill in the missing expressions to complete the following definitions
        of some basic list-manipulation operations as accumulations:
        

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function map(f, sequence) {
    return accumulate((x, y) => ?? , 
                      null, sequence);
}

function append(seq1, seq2) {
    return accumulate(pair, ??, ??);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAWwIYAcAUwA0iDOApgI4iGSECUiA3gFCKOIBOhUIzSqEEIyIAG1RRCmTAA88AT2oBeAHyIA-EsR4GTTVu1MwggXiKlyEKgG46AXzp1QkWAkQZ05ACaYjARkMkATNXpNVnZOJx4+QWFRdFQYZjwVBKVKC2tbcGh4JAFyAHMoAAsPEjIKAI1GYI4ucP4hEUxExAAGH2My1KA}{\usebox\lstbox}!*/
}

function length(sequence) {
    return accumulate(??, 0, sequence);
}

\end{JavaScriptClickable}


	
      \hfill{\hyperref[ex:unlabeled29-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled29}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function map(f, sequence) {
    return accumulate((x, y) => pair(p(x), y),
                      null, 
                      sequence);
}

function append(seq1, seq2) {
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAWwIYAcAUwA0iDOApgI4iGSECUiA3gFCKOIBOhUIzSqEEIyIAG1RRCmTAA88AT2oBeAHyJ0qGM0xZxlaVoZM9+g0zCCBeXYYv6ipchCoBuOgF86dUJFgJEGdOQAmmNYAjHjWAEzU9Hqs7JzePHyCwqLKqqEkYenEQZSOLm7g0PBIAuQA5lAAFoEkZBSR5ixsHFwJ-EIiYpKIMogKPYgA1IghjZaWAAxm4zMEtbYOzkA}{\usebox\lstbox}!*/
    return accumulate(pair, seq2, seq1);
}

function length(sequence) {
    return accumulate((x, y) => y + 1,
                      0, 
                      sequence);
}

\end{JavaScriptClickable}


\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

        
        Evaluating a polynomial in $x$ at a given value of $x$ can be
        formulated as an accumulation.  We evaluate the polynomial
        
          \[ a_{n} x^n +a_{n-1}x^{n-1}+\cdots + a_{1} x+a_{0} \]
        
        using a well-known algorithm called 
        
        <EM>Horner's rule</EM>, which
        structures the computation as
        
          \[ \left(\cdots (a_{n}  x+a_{n-1})x+\cdots +a_{1}\right) x+a_{0} \]
        
        In other words, we start with $a_{n}$, multiply by $x$, add $a_{n-1}$, 
        multiply by $x$, and so on, until we reach $a_{0}$.<a class='superscript' id='footnote-3' href='#footnote-3'>[3]</a>function
        that evaluates a
        polynomial using Horner's rule.
        Assume that the coefficients of the
        polynomial are arranged in a sequence, from $a_{0}$ through $a_{n}$.
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function horner_eval(x, coefficient_sequence) {
    return accumulate((this_coeff, higher_terms) => ??,
                      0, 
                      coefficient_sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABACzgJzAUzQfUwNwEMAbACgA8AaRCOTYYGCGTMKHAZ0wEcRWJMASkQBvAFCJJiNJiggMiQhAggAtiGKEomUqSjIYHHLXrBqBgObJsObWlUdhAXgB8iAPzvKEqb7-+pAAZqHwCwvxMGJhY2Th4+SCEAbjEAXyA}{\usebox\lstbox}



        For example, to compute $1+3x+5x^3+x^5$ at $x=2$ you would evaluate
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
horner_eval(2, list(1, 3, 0, 5, 0, 1));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=BYewTgdgpmD6UDcCGAbAFAJgDQAIUEsBnAFzQEZcBmXABlwFZbcyBKFgbiA}{\usebox\lstbox}


	
      

        Fill in the following template to produce a
        function
        that evaluates a
        polynomial using Horner's rule.
        Assume that the coefficients of the
        polynomial are arranged in a sequence, from $a_{0}$ through $a_{n}$.
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function horner_eval(x, coefficient_sequence) {
    return accumulate((this_coeff, higher_terms) => ??,
                      0, 
                      coefficient_sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABACzgJzAUzQfUwNwEMAbACgA8AaRCOTYYGCGTMKHAZ0wEcRWJMASkQBvAFCJJiNJiggMiQhAggAtiGKEomUqSjIYHHLXrBqBgObJsObWlUdhAXgB8iAPzvKEqb7-+pAAZqHwCwvxMGJhY2Th4+SCEAbjEAXyA}{\usebox\lstbox}



        For example, to compute $1+3x+5x^3+x^5$ at $x=2$ you would evaluate
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
horner_eval(2, list(1, 3, 0, 5, 0, 1));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=BYewTgdgpmD6UDcCGAbAFAJgDQAIUEsBnAFzQEZcBmXABlwFZbcyBKFgbiA}{\usebox\lstbox}


	
      \hfill{\hyperref[ex:horner-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:horner}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function horner_eval(x, coefficient_sequence) {
    return accumulate((this_coeff, higher_terms) => 
                      x * higher_terms + this_coeff,
                      0, 
                      coefficient_sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABACzgJzAUzQfUwNwEMAbACgA8AaRCOTYYGCGTMKHAZ0wEcRWJMASkQBvAFCJJiNJiggMiQhAggAtiGKEomUqSjIYHHLXrBqBgObJsObWlUdhAXgB8iCVM9fvU8ogBUKDBWNnYOiADUiPqGxnQMlB4+yV4ADNRJKVkmDEwsbJw8fJBCANxiAL5AA}{\usebox\lstbox}


\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

        Redefine {\lstinline[mathescape=true]$count_leaves$} from section~\ref{sec:trees} as an
        accumulation:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function count_leaves(t) {
    return accumulate(??, ??, map(??, ??));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABBO4oH0A2BTAhgN2wGcAKKASkQG8AoRexAJ2yhEaVwghAFsRNcUbCQD8IgDSIxknrgAOoiVJHlyAbhoBfIA}{\usebox\lstbox}


	
      \hfill{\hyperref[ex:countleaves-as-accumulation-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:countleaves-as-accumulation}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function count_leaves(t) {
    return accumulate((leaves, total) => leaves + total,
                      0, 
		      map(sub_tree => is_pair(sub_tree)
		             ? count_leaves(sub_tree)
                             : 1,
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABBO4oH0A2BTAhgN2wGcAKKASkQG8AoRexAJ2yhEaVwghAFsRNcUbCRI4CxADSIocKLkyUAvAD5EYwkUQBqabPkS6DI8ZMMADFJoBIKyZ64ADiSIgARuijNsiFYhhF0B1wYRmc3Dy9ya1tTYwB+ZFQwDHViMPdPbGwo2Ny8+gAuRABGAxsYinIAbhoAXyA}{\usebox\lstbox}!*/
			  t));
}

\end{JavaScriptClickable}


\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

        The
        function
        {\lstinline[mathescape=true]$accumulate_n$} is similar to {\lstinline[mathescape=true]$accumulate$} except
        that it takes as its third argument a sequence of sequences, which are all
        assumed to have the same number of elements.  It applies the
        designated accumulation
        function
        to combine all the first elements of
        the sequences, all the second elements of the sequences, and so on, and
        returns a sequence of the results.  For instance, if {\lstinline[mathescape=true]$s$} is a sequence
        containing four sequences

	
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
list(list( 1,  2,  3),
     list( 4,  5,  6),
     list( 7,  8,  9),
     list(10, 11, 12))
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=DYSwzgLgFKlQBARgDT3gJlfAzASmQFBrGzTwAsWArFgGz5HHykIDsWAHFgJwNPPhoiAAypEKJOly4gA}{\usebox\lstbox}


	then the value of {\lstinline[mathescape=true]$accumulate_n(plus, 0, s)$} should be the sequence {\lstinline[mathescape=true]$[22, [26, [30, null]]]$}.  Fill in the missing expressions
        in the following definition of {\lstinline[mathescape=true]$accumulate_n$}:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function accumulate_n(op, init, seqs) {
    return is_null(head(seqs))
           ? null
           : pair(accumulate(op, init, ??), 
                  accumulate_n(op, init, ??));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAQwhEBbEAbZUCmA+mABRwAOANIjGDFNQM74COjAlIgN4BQi-iAE74oIQUhiNiObCQAW+ZABMSzNu3Z8B2gQH5EYGVp3aAXInLIYgkqnRZcBMlRp0GiXbvbVjJv-ztMHDwiUgpqWnpqTw0Abh4AXyA}{\usebox\lstbox}


	
    
    \hfill{\hyperref[ex:accumulate-n-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:accumulate-n}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function accumulate_n(op, init, seqs) {
    return is_null(head(seqs))
           ? null
           : pair(accumulate(op, init, map(x => head(x), seqs)),
                  accumulate_n(op, init, map(x => tail(x), seqs)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAQwhEBbEAbZUCmA+mABRwAOANIjGDFNQM74COjAlIgN4BQi-iAE74oIQUhiNiObCQAW+ZABMSzNu3Z8B2gQH5EYGVp3aAXInLIYgkqnRZcBMlRp0GiDMnIkAHogC8AHyICsq+7EysHBHGJnH8dpg4eESkFNS09NSe3n5BiFBWsj4RiGrR7ADcPAC+QA}{\usebox\lstbox}


\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

        
        
        
        Suppose we represent vectors $v=(v_{i})$ as sequences of numbers, and
        matrices $m=(m_{ij})$ as sequences of vectors (the rows of the matrix).
        For example, the matrix
        
          \[ \left[ 
          \begin{array}{llll}
          1 & 2 & 3 & 4\\
          4 & 5 & 6 & 6\\
          6 & 7 & 8 & 9\\
          \end{array}
          \right] \]
        
	<SPLIT>
	  
	  
	    is represented as the following sequence:
	    
\begin{JavaScript}
[[1, [2, [3, [4, null]]]], 
 [[4, [5, [6, [6, null]]]], 
  [[6, [7, [8, [9, null]]]], null]]]
\end{JavaScript}

	  
	</SPLIT>
        With this representation, we can use sequence operations to concisely
        express the basic matrix and vector operations.  These operations
        (which are described in any book on matrix algebra) are the following:


        <UL>
          <LI>
          {\lstinline[mathescape=true]$dot_product($}$v${\lstinline[mathescape=true]$, $}$w${\lstinline[mathescape=true]$)$} returns the sum $\sum_{i}v_{i}
            w_{i}$.
          </LI>
          <LI>
            {\lstinline[mathescape=true]$matrix_times_vector($}$m${\lstinline[mathescape=true]$, $}$v${\lstinline[mathescape=true]$)$} returns the vector $t$, where $t_{i} =\sum_{j}m_{ij}v_{j}$.
          </LI>
          <LI>
            {\lstinline[mathescape=true]$matrix_times_matrix($}$m${\lstinline[mathescape=true]$, $}$n${\lstinline[mathescape=true]$)$} returns the matrix $p$, where $p_{ij}=\sum_{k} m_{ik}n_{kj}$.
          </LI>
          <LI>
            {\lstinline[mathescape=true]$transpose($}$m${\lstinline[mathescape=true]$)$} returns the matrix $n$, where $n_{ij}=m_{ji}$.
          </LI>
        </UL>
        We can define the dot product as<a class='superscript' id='footnote-4' href='#footnote-4'>[4]</a>
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function dot_product(v, w) {
    return accumulate(plus, 0, 
                      accumulate_n(times, 1, list(v, w)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAEzlA+gBwE52SaACgDcAaRAdwEpEBvAKEScWwFMoRskBDCCEALYgANtyitCmYSADO5AAzlGzFarXNe-IaPHowhWANZzEARnLCYMqCXLUqVANz0AvkA}{\usebox\lstbox}


        

        Fill in the missing expressions in the following
        functions
        for
        computing the other matrix operations.  (The
        function
        {\lstinline[mathescape=true]$accumulate_n$} is
        defined in exercise~\ref{ex:accumulate-n}.)
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function matrix_times_vector(m, v) {
    return map(??, m);
}

function transpose(mat) {
    return accumulate_n(??, ??, mat);
}

\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAWwIZQE4wB4H1bICmAzrgG6HRwYAUyANImQJSIDeAUIt4hoVCAxI0ABxoB+cY2TMA3BwC+HDqEiwEiTKjDERcYoTrpWnHr36CkqCBBDIQAG3SFcYCVMSTpx+UpXhoeGF0LDwCElw0TBwaMGkTLh4IBGIoRGSHYkQAXk0MbV19QzA5RO4+ASEUVDEvFFKFIA}{\usebox\lstbox}!*/
function matrix_times_matrix(n, m) {
    const cols = transpose(n);
    return map(??, m);
}

\end{JavaScriptClickable}


  
    
      
          
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function dot_product(v, w) {
    return accumulate(plus, 0, 
                      accumulate_n(times, 1, list(v, w)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAEzlA+gBwE52SaACgDcAaRAdwEpEBvAKEScWwFMoRskBDCCEALYgANtyitCmYSADO5AAzlGzFarXNe-IaPHowhWANZzEARnLCYMqCXLUqVANz0AvkA}{\usebox\lstbox}


        

        Fill in the missing expressions in the following
        functions
        for
        computing the other matrix operations.  (The
        function
        {\lstinline[mathescape=true]$accumulate_n$} is
        defined in exercise~\ref{ex:accumulate-n}.)
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function matrix_times_vector(m, v) {
    return map(??, m);
}

function transpose(mat) {
    return accumulate_n(??, ??, mat);
}

\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAWwIZQE4wB4H1bICmAzrgG6HRwYAUyANImQJSIDeAUIt4hoVCAxI0ABxoB+cY2TMA3BwC+HDqEiwEiTKjDERcYoTrpWnHr36CkqCBBDIQAG3SFcYCVMSTpx+UpXhoeGF0LDwCElw0TBwaMGkTLh4IBGIoRGSHYkQAXk0MbV19QzA5RO4+ASEUVDEvFFKFIA}{\usebox\lstbox}!*/
function matrix_times_matrix(n, m) {
    const cols = transpose(n);
    return map(??, m);
}

\end{JavaScriptClickable}


  
    
      \hfill{\hyperref[ex:matrix-ops-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:matrix-ops}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function matrix_times_vector(m, v) {
    return map(row => dot_product(row, v), m);
}

function transpose(mat) {
    return accumulate_n(pair, null, mat);
}

\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAWwIZQE4wB4H1bICmAzrgG6HRwYAUyANImQJSIDeAUIt4hoVCAxI0ABxoY4Ad0QBeAHyIAJnCi4RExSGjipjFo2TMA3BwC+HDqEiwEiTKjDERcYoTrpWnHr36CkqCAgQZBAAG3RCXDAaEVQYDEYwMNCDDxNzS3BoeGF0LDwCElw0TBwaMANPLh4IBGIoRFrQ4lk7DAcnFzdDE28+ASEUVDFsWQVRGgBPMaUVNQ0tKBpsRknmRibidcQwYzMgA}{\usebox\lstbox}!*/
function matrix_times_matrix(n, m) {
    const cols = transpose(m);
    return map(x => map(y => dot_product(x, y), cols), n);
}

\end{JavaScriptClickable}


\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

        
        
        The {\lstinline[mathescape=true]$accumulate$}
        function
        is also known as {\lstinline[mathescape=true]$fold_right$}, 
        because it combines the first element of the sequence with the result
        of combining all the elements to the right.  There is also a {\lstinline[mathescape=true]$fold_left$}, which is 
        similar to {\lstinline[mathescape=true]$fold_right$}, except
        that it combines elements working in the opposite direction:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function fold_left(op, initial, sequence) {
    function iter(result, rest) {
        return is_null(rest)
               ? result
               : iter(op(result, head(rest)), 
                      tail(rest));
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABMOAbAJgfVQU2FACjgAcAaRGMGWAQ1XIGccBHEHSHASkQG8AoRIOTho8JNRwAnApJwMQqKOVkMo3fkM2JZUEJPENMYBahly1ArVaEB+bXIVRL1qwC4KUKUWJn5i8gAWODTovmqc5M4u0YJQNDCmKuEA3FEAvlE6euKe0pTUMHSMLGwcnKlpQA}{\usebox\lstbox}!*/
    }
    return iter(initial, sequence);
}

\end{JavaScriptClickable}



        

        What are the values of
        
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
fold_right(divide, 1, list(1, 2, 3));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYewNgJg+gTglgcwBYBcAUE4Dc4QKYA0ABAIzFhwDO6ZRATMQMwCUzA3EA}{\usebox\lstbox}


        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
fold_left(divide, 1, list(1, 2, 3));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYewNgJg+mCmwBcAUECWA3VFYBoAEAjPmKgM7JF4BM+AzAJT0DcQA}{\usebox\lstbox}


        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
fold_right(list, null, list(1, 2, 3));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYewNgJg+gTglgcwBYBcAUY4GcUBoAEAdgK5hgGY5oCMBATAQMwCUzA3EA}{\usebox\lstbox}


        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
fold_left(list, null, list(1, 2, 3));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYewNgJg+mCmwBcAUYCWBnBAaABAOwFcwxc1MkBGXAJlwGYBKBgbiA}{\usebox\lstbox}



        Give a property that {\lstinline[mathescape=true]$op$} should satisfy to guarantee that {\lstinline[mathescape=true]$fold_right$} and {\lstinline[mathescape=true]$fold_left$} will produce the same values for any
        sequence.
        
   
      \hfill{\hyperref[ex:fold-right-left-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:fold-right-left}]

     We can guarantee that {\lstinline[mathescape=true]$fold_right$} and
     {\lstinline[mathescape=true]$fold_left$} produce
     the same values for any sequence, if we require that
     {\lstinline[mathescape=true]$op$} is commutative and associative.
 
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
fold_right(plus, 0, list(1, 2, 3));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYewNgJg+gTglgcwBYBcAUAHMBXAzgGgAIAGIsOXdARiICYiBmASiYG4g}{\usebox\lstbox}



\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
fold_left(plus, 0, list(1, 2, 3));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYewNgJg+mCmwBcAUAHMBXAzgGgAQAY8wBLTZARjwCY8BmASnoG4g}{\usebox\lstbox}


   
\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled30}

        Complete the following definitions of {\lstinline[mathescape=true]$reverse$}
        
        (exercise~\ref{ex:reverse}) in terms of {\lstinline[mathescape=true]$fold_right$} and {\lstinline[mathescape=true]$fold_left$} from exercise~\ref{ex:fold-right-left}:

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function reverse(sequence) {
    return fold_right((x, y) => ??, null, sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAJwKYDdXIM6oBS4COIqkqAlIgN4BQi9KqUIySwcANgCYD6yMAcwAWUPHgAeAGkQBPSgF4AfIgD8K6WBAcO0oiTLkA3DQC+QA}{\usebox\lstbox}



        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function reverse(sequence) {
    return fold_left((x, y) => ??, null, sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAJwKYDdXIM6oBS4COIqkqAlIgN4BQi9KqUIySwcANgCYD6HqwKHjwAPADSIAnpQC8APkQB+RRLAgOHCURJlyAbhoBfIA}{\usebox\lstbox}



	
	
      \hfill{\hyperref[ex:unlabeled30-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled30}]

  
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function reverse(sequence) {
    return fold_right((x, y) => append(y, list(x)), 
                      null, sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAJwKYDdXIM6oBS4COIqkqAlIgN4BQi9KqUIySwcANgCYD6yMAcwAWUPHgAeAGkQBPSgF4AfIgCGABzWkueGdI4xso8eXLS6DC5asMwIDh2lESZcgG4aAXyA}{\usebox\lstbox}




\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function reverse(sequence) {
    return fold_left((x, y) => pair(y, x), null, sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAJwKYDdXIM6oBS4COIqkqAlIgN4BQi9KqUIySwcANgCYD6HqwKHjwAPADSIAnpQC8APkQAHAIYxkeSRJHkJYEBw4SiJMuQDcNAL5A}{\usebox\lstbox}



\end{Answer}

      

      \subsubsection{
        Nested Mappings
      

      
      

      <div class='permalink'>
<a name='p21' class='permalink'></a><p>
        We can extend the sequence paradigm to include many
        computations that are commonly expressed using nested 
        loops.<a class='superscript' id='footnote-5' href='#footnote-5'>[5]</a>
      </p></div>

      <div class='permalink'>
<a name='p22' class='permalink'></a><p>
        Consider
        this problem: Given a positive integer $n$, find all ordered pairs of
        distinct positive integers $i$ and $j$, where $1\leq j< i\leq n$, such
        that $i +j$ is prime.  For example, if $n$ is 6, then the pairs are
        the following:
        
          \[
          \begin{array}{c|ccccccc}
          i     & 2 & 3 & 4 & 4 & 5 & 6 & 6 \\
          j     & 1 & 2 & 1 & 3 & 2 & 1 & 5 \\
          \hline
          i+j   & 3 & 5 & 5 & 7 & 7 & 7 & 11
          \end{array}
          \]
        
      </p></div>

      <div class='permalink'>
<a name='p23' class='permalink'></a><p>
        A natural way to organize this computation is to generate the sequence
        of all ordered pairs of positive integers less than or equal to $n$, 
        filter to select those pairs whose sum is prime, and
        then, for each pair $(i, j)$ that passes through the filter, produce the triple
        $(i, j, i+j)$.
      </p></div>

      <div class='permalink'>
<a name='p24' class='permalink'></a><p>
        Here is a way to generate the sequence of pairs: For each integer
        $i\leq n$, enumerate the integers $j<i$, and for each such $i$ and $j$
        generate the pair $(i, j)$.  In terms of sequence operations, we map
        along the sequence {\lstinline[mathescape=true]$enumerate_interval(1, n)$}.  For each $i$ in
        this sequence, we map along the sequence {\lstinline[mathescape=true]$enumerate_interval(1, i-1)$}.  For each $j$ in this latter sequence, we generate the pair
        {\lstinline[mathescape=true]$list(i, j)$}.  This gives us a sequence of pairs for each $i$.
        Combining all the sequences for all the $i$ (by accumulating with {\lstinline[mathescape=true]$append$}) produces the required sequence of pairs:<a class='superscript' id='footnote-6' href='#footnote-6'>[6]</a>

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
accumulate(append, 
           null, 
           map(i => map(j => list(i, j),
                        enumerate_interval(1, i-1)),
               enumerate_interval(1, n)));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=IYYxFcFtwG2AXApgCmABzYgdgEwDQAEAUAaWeQVrDISRRZOsgJYEC8AfAY2sgFbsuMZgGd4LQnwCUeOvXkKC2KIgBOCRAH1mWJKoBuwGMgCMhZgFoTUmXMVllkNRu261h42co2pAbiA}{\usebox\lstbox}


      

        

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
accumulate(append, 
           null, 
           map(i => map(j => list(i, j),
                        enumerate_interval(1, i-1)),
               enumerate_interval(1, n)));
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=IYYxFcFtwG2AXApgCmABzYgdgEwDQAEAUAaWeQVrDISRRZOsgJYEC8AfAY2sgFbsuMZgGd4LQnwCUeOvXkKC2KIgBOCRAH1mWJKoBuwGMgCMhZgFoTUmXMVllkNRu261h42co2pAbiA}{\usebox\lstbox}


      </p></div>

      <div class='permalink'>
<a name='p25' class='permalink'></a><p>
        The combination of mapping and accumulating with {\lstinline[mathescape=true]$append$} is so common in this
        sort of program that we will isolate it as a separate
        function:
        
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function flatmap(f, seq) {
    return accumulate(append, null, map(f, seq));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABMANgQygWzQBwBTAA0iAzgKYCOAlIgN4BQiTiATmVCC0mhBCJiHRQyeXDjJgAJsTCCUxbPiKlKVKgG56AXyA}{\usebox\lstbox}



        
      </p></div>

      <div class='permalink'>
<a name='p26' class='permalink'></a><p>
        Now filter this sequence of pairs to find those whose sum is prime. The
        filter predicate is called for each element of the sequence; its
        argument is a pair and it must extract the integers from the pair.
        Thus, the predicate to apply to each element in the sequence is
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function is_prime_sum(pair) {
    return is_prime(head(pair) + head(tail(pair)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABDAzgfQA4CcYFsCmaKIuAFBgIYxYCUiA3gFCIuJb5QhZKqY4GkAFvgoATclVqIA1ImFjSUKgBsJ1GhoDcjAL5A}{\usebox\lstbox}


        
      </p></div>

      <div class='permalink'>
<a name='p27' class='permalink'></a><p>
        Finally, generate the sequence of results by mapping over the filtered
        pairs using the following
        function, which constructs a triple
        consisting of the two elements of the pair along with their sum:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function make_pair_sum(pair) {
    return list(head(pair), head(tail(pair)), 
                head(pair) + head(tail(pair)));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAWwIYGsCmB9ADqmAJ2wGcRkAKfIgSkQG8AoRFxQzKEQpAGxhKgUAFplQATKgUI0ANIhHiKUAj0m1ZiZq207WCidWmIA1PNETlMVYZq2A3IwC+QA}{\usebox\lstbox}


        
      </p></div>

      <div class='permalink'>
<a name='p28' class='permalink'></a><p>
        Combining all these steps yields the complete
        function:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function prime_sum_pairs(n) {
    return map(make_pair_sum, 
             filter(is_prime_sum, 
               flatmap(i => map(j => list(i, j), 
                                enumerate_interval(1, i - 1)),
                       enumerate_interval(1, n))));
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABABwE4wLYFMD6BnEDHZAQxlTwAowBKRAbwChEXFUsoRUkMTlLeAa1yly+QgBpEzVrLnAYAGyhZUlGHmLps4jFJlzDLYIpJRe-GIgC8APkQXKAKxv3FGqOqlOa+o-4D-LDBCVTNcGDAVVAA3EkVKAEYpKwBaRESaXwNAwODQ1HCcSOi4hOTEWiyaAG5GAF8gA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}



        

      </p></div>

      <div class='permalink'>
<a name='p29' class='permalink'></a><p>
        Nested mappings are also useful for sequences other than those that
        enumerate intervals.  Suppose we wish to generate all the 
        
        
        permutations
        of a set $S$; that is, all the ways of ordering the items in
        the set.  For instance, the permutations of $\{1, 2, 3\}$ are
        $\{1, 2, 3\}$, $\{ 1, 3, 2\}$, $\{2, 1, 3\}$, $\{ 2, 3, 1\}$, $\{ 3, 1, 2\}$, and
        $\{ 3, 2, 1\}$.  Here is a plan for generating the permutations of~$S$:
        For each item $x$ in $S$, recursively generate the sequence of
        permutations of $S-x$, <a class='superscript' id='footnote-7' href='#footnote-7'>[7]</a>$x$ to the front of each one.  This yields, for each $x$ in $S$, the sequence
        of permutations of $S$ that begin with~$x$.  Combining these
        sequences for all $x$ gives all the permutations of~$S$:<a class='superscript' id='footnote-8' href='#footnote-8'>[8]</a>
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function permutations(s) {
    return is_null(s)
           ? list(null)
           : flatmap(x => map(p => pair(x, p),
                              permutations(remove(x, s))),
                     s);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABABwKYCcC2IoENYIDOAFIQJSIDeAUInYuqlCOkjIQPpggA2PpZWvWH0A-Ih7soxbn0EiFALkTAe+TLmTEAHogC8APkQatyfUeS4Y6HQBoUZW0IUvXLtFhz54YEo0xwAG6odojkZI7Obm7kANzUAL5AA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}



        

      

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function permutations(s) {
    return is_null(s)
           ? list(null)
           : flatmap(x => map(p => pair(x, p),
                              permutations(remove(x, s))),
                     s);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABABwKYCcC2IoENYIDOAFIQJSIDeAUInYuqlCOkjIQPpggA2PpZWvWH0A-Ih7soxbn0EiFALkTAe+TLmTEAHogC8APkQatyfUeS4Y6HQBoUZW0IUvXLtFhz54YEo0xwAG6odojkZI7Obm7kANzUAL5AA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}



        

       and adjoin
        $x$ to the front of each one.  This yields, for each $x$ in $S$, the sequence
        of permutations of $S$ that begin with~$x$.  Combining these
        sequences for all $x$ gives all the permutations of~$S$:<a class='superscript' id='footnote-9' href='#footnote-9'>[9]</a>
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function permutations(s) {
    return is_null(s)
           ? list(null)
           : flatmap(x => map(p => pair(x, p),
                              permutations(remove(x, s))),
                     s);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABABwKYCcC2IoENYIDOAFIQJSIDeAUInYuqlCOkjIQPpggA2PpZWvWH0A-Ih7soxbn0EiFALkTAe+TLmTEAHogC8APkQatyfUeS4Y6HQBoUZW0IUvXLtFhz54YEo0xwAG6odojkZI7Obm7kANzUAL5AA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}



        

      

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function permutations(s) {
    return is_null(s)
           ? list(null)
           : flatmap(x => map(p => pair(x, p),
                              permutations(remove(x, s))),
                     s);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABABwKYCcC2IoENYIDOAFIQJSIDeAUInYuqlCOkjIQPpggA2PpZWvWH0A-Ih7soxbn0EiFALkTAe+TLmTEAHogC8APkQatyfUeS4Y6HQBoUZW0IUvXLtFhz54YEo0xwAG6odojkZI7Obm7kANzUAL5AA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}



        

      </p></div>

      <div class='permalink'>
<a name='p30' class='permalink'></a><p>
        Notice how this strategy reduces the problem of generating
        permutations of $S$ to the problem of generating the permutations of
        sets with fewer elements than $S$.  In the terminal case, we work our
        way down to the empty list, which represents a set of no elements.
        For this, we generate {\lstinline[mathescape=true]$list(null)$}, which is a sequence with one
        item, namely the set with no elements.  The {\lstinline[mathescape=true]$remove$}
        function
        used in {\lstinline[mathescape=true]$permutations$} returns all the items in a given sequence
        except for a given item.  This can be expressed as a simple filter:
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function remove(item, sequence) {
    return filter(x => !(x === item),
                  sequence);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAJwKYFs4DdUAoZQYA0iAzqgI4iqSoCUiA3gFCJsqpQjJLAwA2hZLgAeiALwA+RAEJRE8eMQEMdIq3aatW8lRoR6AbmYBfIA}{\usebox\lstbox}


        
      </p></div>

      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled31}

        Define a
        function

        
        {\lstinline[mathescape=true]$unique_pairs$} that, given an integer $n$, 
        generates the sequence of pairs $(i, j)$ with $1\leq j< i\leq n$.  Use {\lstinline[mathescape=true]$unique_pairs$} to simplify the definition of {\lstinline[mathescape=true]$prime_sum_pairs$}
        given above.
   
      \hfill{\hyperref[ex:unlabeled31-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled31}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function unique_pairs(n) {
    return flatmap(i => map(j => list(i, j), 
                            enumerate_interval(1, i-1)), 
                   enumerate_interval(1, n));
}
function prime_sum_pairs(n) {
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABOGBHEBTA+gBwIYwBOAzgBRgCUiA3gFCIOKEZQiFLAA2eUAtnjlIxEAXgB8ifoIBWoiZxjEoQgDSJpFNfUY7de-QwxgQvDIR7YYYKGYBueTqQCMamAFonFTYm0G-RkzMLLCsbQntHF0RKCgBuWgBfWlBIWAREHEIYUyxiE1wCEnIqOh1mVnZJAVJ+AGtsfCJcky0-PWAYTjChYlwsnLzeVraRlHQGwrIYuMSgA}{\usebox\lstbox}!*/
    return map(make_pair_sum, 
               filter(is_prime_sum, 
                      unique_pairs(n)));
}

\end{JavaScriptClickable}


    
    
\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled32}

        Write a
        function
        to find all ordered
        triples of distinct positive integers $i$, $j$, and~$k$ less than or
        equal to a given integer $n$ that sum to a given integer $s$.
    
      \hfill{\hyperref[ex:unlabeled32-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled32}]

      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function unique_triples(n) {
    return flatmap(i => flatmap(j => map(k => list(i, j, k),
                                         enumerate_interval(1, j-1)),
                                enumerate_interval(1, i-1)),
                   enumerate_interval(1, n));
}
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABOGBHEBTA+lATjABwBsMBnACjAEpEBvAKEScVwyhFyWCIEMoBbHgXIxEAXgB8ibn0HCAVuKlzyAayWIiMUlBEAaRPIOqqexswuWr1m9YxgQ-DLj7YYYKM4BuPIuQCMBvIAtP5Upua2UdH2js6uWO6euD5+gYgwoeFm0TaxTi6eiR7evgEG1FQA3PQAvvSgkLAIiMQgFAAeBgCeNAwWrOyciB2IANSI3TX1jdDwSHiEJKQ4ABZ8WKSOOHDkpBV9kSxsHFwwRMkinvykGjwQEI4gvJ7kbfuIAAwGMNekNGJAYh9kdckwUOhsItiGRKOFpkA}{\usebox\lstbox}!*/
function plus(x, y) {
    return x + y;
}
function triples_that_sum_to(s, n) {
    return filter(items => accumulate(plus, 0, items) === s,
                  unique_triples(n));
}

\end{JavaScriptClickable}


    
    
\end{Answer}


      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

        

              
\begin{figure}[H]
\centering

\maxsizebox{\linewidth}{0.8\paperheight}{\includegraphics[scale=0.8]{{img\string_original/ch2-Z-G-23}.svg}}
\caption{A solution to the eight-queens puzzle.
                }
\label{fig:8queens}
\end{figure}

        The 
        
        
        <QUOTE>eight-queens puzzle</QUOTE> asks how to place eight queens on a
        chessboard so that no queen is in check from any other (i.e., no two
        queens are in the same row, column, or diagonal).  One possible
        solution is shown in Figure~\ref{fig:8queens}.  One way to solve the
        puzzle is to work across the board, placing a queen in each column.
        Once we have placed $k-1$ queens, we must place the $k$th queen in a
        position where it does not check any of the queens already on the
        board.  We can formulate this approach recursively: Assume that we
        have already generated the sequence of all possible ways to place
        $k-1$ queens in the first $k-1$ columns of the board.  For each of
        these ways, generate an extended set of positions by placing a queen
        in each row of the $k$th column.  Now filter these, keeping only
        the positions for which the queen in the $k$th column is safe with
        respect to the other queens.  This produces the sequence of all ways
        to place $k$ queens in the first $k$ columns.  By continuing this
        process, we will produce not only one solution, but all solutions to
        the puzzle.

        We implement this solution as a
        function
        {\lstinline[mathescape=true]$queens$}, which returns
        a sequence of all solutions to the problem of placing $n$ queens on an
        $n\times n$ chessboard.  The function {\lstinline[mathescape=true]$queens$} has an internal
        function
        {\lstinline[mathescape=true]$queens_cols$} that returns the sequence of all ways to place queens in
        the first $k$ columns of the board.

        
	
        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function queens(board_size) {
    function queen_cols(k) {
        return k === 0
               ? list(empty_board)
               : filter(
                     positions => is_safe(k, positions), 
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABARxAUzWAzgCgEZwCGATgCYD6WMAXmgJSIDeAUIm4qJLAiupuRDgAbXAGsGLdlMTE0UEMSSjEAXjWIADK2k72AfkRCYWKDjQBbAA5QAnuQIlSdbbp0AuDjCFQ0xHC9dAxEs4Km5sVQA+RGNKQmA0HFEAGmDQmHCsOlSAoN1gIUIoc0JLHFkTcjhgclQMCJVo5gBIVukSsrA0AHdyYjhuqMRCUgArOBgwchCw+DB-PMWlwK7e-u7UlNzlnbyKqCqauswsnN3zzBBzXyK0ckmfYgA3QiEcAEYz8+-EBzJKGj0bItNpSY5TQQiJKIAC0iHedERAG4XABfFyyeSKXj1ATCXB-ChUWh0FGooA}{\usebox\lstbox}!*/
                     flatmap(rest_of_queens => 
			     map(new_row => adjoin_position(
                                             new_row, k,
                                             rest_of_queens), 
                                 enumerate_interval(1, 
                                     board_size)),
			     queen_cols(k - 1)));
   }
   return queen_cols(board_size);
}

\end{JavaScriptClickable}



        In this
        function
        {\lstinline[mathescape=true]$rest_of_queens$} is a way to place $k-1$ queens
        in the first $k-1$ columns, and {\lstinline[mathescape=true]$new_row$} is a proposed row in
        which to place the queen for the $k$th column.  Complete the program
        by implementing the representation for sets of board positions, 
        including the
        function
        {\lstinline[mathescape=true]$adjoin_position$}, which adjoins a new row-column
        position to a set of positions, and {\lstinline[mathescape=true]$empty_board$}, which
        represents an empty set of positions.  You must also write the
        function
        {\lstinline[mathescape=true]$is_safe$}, which determines for a set of positions, 
        whether the queen in the $k$th column is safe with respect to the
        others.  (Note that we need only check whether the new queen is
        safeâ€”the other queens are already guaranteed safe with respect to
        each other.)



      \hfill{\hyperref[ex:8queens-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:8queens}]



        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function adjoin_position(row, col, rest) {
    return pair(pair(row, col), rest);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAQwCYCs4zAfQA5wDOMsCAFAE5wDuANIhHADb0UCmhUAlIgN4BQiIYnZQQFJHmQwKZKTMo16jJl1YduAbn4BfIA}{\usebox\lstbox}



        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
const empty_board = null;
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=MYewdgzgLgBApgWwA5QJ4H0BGICGAnAExgF4YwBXAG0oG4g}{\usebox\lstbox}



        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function is_safe(k, positions) {
    const first_row = head(head(positions));
    const first_col = tail(head(positions));
    return accumulate((pos, so_far) => {
                         const row = head(pos);
                         const col = tail(pos);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABDAzgfRQQ2AUwBQDWANIgA5woywIoCUiA3gFCKuIQ1SLAwBOKUNLzgB3RAF5EACxyYAJnhny85StTB1aAbhZsOGrj36COAGwmIomGKcWyFqqvA21tu1rxxQQvJJggQIAC2IKaYUPgqFCQocGjAmLz04gB8jO5smVnZmfoCiMJikkoOFG45FZXsnNXmklY2UXQ6Va2Znt6+iLHxiYgAZP0ZbSNsRgJCoogAtNx8E2aIAITi4sOjI4UztQNDG-tzxpNiANSHC3DmK2sHG1tni4PrtxXjglvXBaItL6wAvkRnhsoLwQDgSEDRg1bI51JodH8gA}{\usebox\lstbox}!*/
                         return so_far &&
                                first_row - first_col !==
                                row - col &&
                                first_row + first_col !==
                                row + col &&
                                first_row !== row;
                      },
                      true, 
                      tail(positions));
}

\end{JavaScriptClickable}



	Putting it all together:

        
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
// click here to see the solution
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=PTAEGMBsEtwa1ACwKYCdmgC4HtQGdkNMV9tIBXTabAOyA}{\usebox\lstbox}




\end{Answer}

      

      
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled33}

        Louis Reasoner is having a terrible time doing exercise~\ref{ex:8queens}.  His
        {\lstinline[mathescape=true]$queens$}
        function
        seems to work, but it runs extremely slowly.
        (Louis never does manage to wait long enough for it to solve even the
        $6\times 6$ case.)  When Louis asks Eva Lu Ator for help, she points
        out that he has interchanged the order of the nested mappings in the
        {\lstinline[mathescape=true]$flatmap$}, writing it as
        
\begin{JavaScript}
flatmap(new_row =>
        map(rest_of_queens => adjoin_position(
                               new_row, k, 
                               rest_of_queens), 
	    queen_cols(k - 1)), 
        enumerate_interval(1, board_size));
\end{JavaScript}


        Explain why this interchange makes the program run slowly.  Estimate
        how long it will take Louis's program to solve the eight-queens
        puzzle, assuming that the program in exercise~\ref{ex:8queens} solves
        the puzzle in time $T$.

	

      \hfill{\hyperref[ex:unlabeled33-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled33}]

	  Louis's program re-evaluates the application {\lstinline[mathescape=true]$queen_cols(k - 1))$}
	  in each iteration of {\lstinline[mathescape=true]$flatmap$},
	  which happens $n$
	  times for each $k$. That
	  means overall Louis's program will solve the puzzle in a time of about
	  $n^n T$ if the program in
	  exercise~\ref{ex:8queens} solves the  puzzle in time 
	  $T$.
	
\end{Answer}

      
      
      
      
    <hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>This 
          is, in fact, precisely the 
          
          {\lstinline[mathescape=true]$fringe$}
          function
          from
          exercise~\ref{ex:fringe}.  Here we've renamed it to emphasize that
          it is part of a family of general sequence-manipulation
          functions.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>
          
          Richard Waters (1979)
          developed a program that automatically analyzes traditional 
          
          Fortran
          programs, viewing them in terms of maps, filters, and accumulations.
          He found that fully 90 percent of the code in the Fortran Scientific
          Subroutine Package fits neatly into this paradigm.  One of the reasons
          for the success of Lisp as a programming language is that lists
          provide a standard medium for expressing ordered collections so that
          they can be manipulated using higher-order operations.  The
          programming language 
          
          APL owes much of its power and appeal to a
          similar choice. In APL all data are represented as arrays, and there is a
          universal and convenient set of generic operators for all sorts of
          array operations.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>According to 
          
          Knuth (1981), this rule was formulated by
          
          W. G. Horner early in the nineteenth century, but the method was
          actually used by Newton over a hundred years earlier.  Horner's rule
          evaluates the polynomial using fewer additions and multiplications
          than does the straightforward method of first computing $a_{n} x^n$, 
          then adding $a_{n-1}x^{n-1}$, and so on.  In fact, it is possible to
          prove that any algorithm for evaluating arbitrary polynomials must use
          at least as many additions and multiplications as does Horner's rule, 
          and thus Horner's rule is an 
          
          
          optimal algorithm for polynomial
          evaluation.  This was proved (for the number of additions) by
          
          A. M. Ostrowski in a 1954 paper that essentially founded the modern
          study of optimal algorithms.  The analogous statement for
          multiplications was proved by 
          
          V. Y. Pan in 1966.  The book by 
          
          
          Borodin and Munro (1975) 
          provides an overview of these and other results about
          optimal algorithms.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>This definition uses
	
	  
	  
	    the function {\lstinline[mathescape=true]$accumulate_n$}
	    from exercise~\ref{ex:accumulate-n}.
	  
	
      </FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>This approach to nested mappings was shown
          to us by 
          
          David Turner, whose languages 
          
          KRC and 
          
          Miranda provide elegant
          formalisms for dealing with these constructs.  The examples in this
          section (see also exercise~\ref{ex:8queens}) are adapted from Turner
          1981.  In section~\ref{sec:exploiting-streams}, we'll see how this
          approach generalizes to infinite sequences.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>We're
          representing a pair here as a list of two elements rather than as
          an ordinary pair.  Thus, the <QUOTE>pair</QUOTE> $(i, j)$ is represented as {\lstinline[mathescape=true]$list(i, j)$}, not {\lstinline[mathescape=true]$pair(i, j)$}.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>The set $S-x$ is the set of all elements
          of $S$, excluding $x$.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>
          
          
          
          The character sequence {\lstinline[mathescape=true]$//$} in JavaScript code is used to
          introduce <EM>comments</EM>.  Everything from {\lstinline[mathescape=true]$//$} to the end of
          the line is ignored by the interpreter.  In this book we don't use
          many comments; we try to make our programs self-documenting by using
          descriptive names.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>
          
          
          
          The character sequence {\lstinline[mathescape=true]$//$} in JavaScript code is used to
          introduce <EM>comments</EM>.  Everything from {\lstinline[mathescape=true]$//$} to the end of
          the line is ignored by the interpreter.  In this book we don't use
          many comments; we try to make our programs self-documenting by using
          descriptive names.</FOOTNOTE></div>
</SUBSECTION>