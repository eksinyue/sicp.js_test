<div id='permalink-msg'>
<div class='screen'>
	<div class='alert alert-success'>
		<strong>Permalink copied!</strong>
	</div>
</div>
</div>

<div class='chapter-content'>
<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>2.2  Hierarchical Data and the Closure Property</a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SECTION'><SECTION>

    <SECTIONCONTENT></SECTIONCONTENT>

    
    <div class='permalink'>
<a name='p1' class='permalink'></a><p>
      As we have seen, pairs provide a primitive <QUOTE>glue</QUOTE> that we can use to
      construct compound data objects.
      Figure \ref{fig:first-box-and-pointer} shows a standard way to
      visualize a 
      
      pair—in this case, the pair formed by <kbd>pair(1,2)</kbd>.

      <SPLIT>
	
	

              
\begin{figure}[H]
\centering

\maxsizebox{\linewidth}{0.8\paperheight}{\includegraphics[scale=0.8]{{img\string_javascript/ch2-Z-G-11}.svg}}
\caption{Box-and-pointer representation of <kbd>pair(1,2)</kbd>.
                }
\label{fig:first-box-and-pointer}
\end{figure}


      In this representation, which is called 
      
      <EM>box-and-pointer
        notation</EM>, each compound object is shown as a 
      
      <EM>pointer</EM> to a box.  The box for a pair
      has two parts, the left part containing the head of the pair and the
      right part containing the tail.<a class='superscript' id='footnote-link-1' href='#footnote-1'>[1]</a>
	  
	
      </SPLIT>


    </p></div>

    <div class='permalink'>
<a name='p2' class='permalink'></a><p>
      We have already seen that <kbd>pair</kbd> can be used to combine not
      only numbers but pairs as well.  (You made use of this fact, or
      should have, in doing exercises \ref{ex:segments1}
      and \ref{ex:rectangles}.)  As a consequence, pairs provide a universal
      building block from which we can construct all sorts of data
      structures.  Figure \ref{fig:box-and-pointer-two-ways} 
      shows two ways to use pairs to combine the numbers 1, 2, 3, and 4.

      <SPLIT>
	
	
              
\begin{figure}[H]
\centering

\maxsizebox{\linewidth}{0.8\paperheight}{\includegraphics[scale=0.8]{{img\string_javascript/ch2-Z-G-12}.svg}}
\caption{Two ways to combine 1, 2, 3, and 4 using pairs.
                }
\label{fig:box-and-pointer-two-ways}
\end{figure}

	
      </SPLIT>
    </p></div>


    <div class='permalink'>
<a name='p3' class='permalink'></a><p>
      The ability to create pairs whose elements are pairs is the essence of
      list structure's importance as a representational tool.  We refer to
      this ability as the 
      
      
      <EM>closure property</EM> of <kbd>pair</kbd>.  In general,
      an operation for combining data objects satisfies the closure property
      if the results of combining things with that operation can themselves
      be combined using the same 
      operation.<a class='superscript' id='footnote-link-2' href='#footnote-2'>[2]</a>
      Closure is the key to power in
      any means of combination because it permits us to create 
      
      
      <EM>
        hierarchical</EM> structures—structures made up of parts, which
      themselves are made up of parts, and so on.
    </p></div>

    <div class='permalink'>
<a name='p4' class='permalink'></a><p>
      From the outset of chapter 1, we've made essential use of closure in
      dealing with
      functions, because all but the very simplest programs
      rely on the fact that the elements of a combination can themselves be
      combinations.  In this section, we take up the consequences of closure
      for compound data.  We describe some conventional techniques for using
      pairs to represent sequences and trees, and we exhibit a graphics
      language that illustrates closure in a vivid 
      way.<a class='superscript' id='footnote-link-3' href='#footnote-3'>[3]</a>
    </p></div>

    <hr><div class='footnote'>
<a class='footnote-number' id='footnote-1' href='#footnote-link-1'>[1] </a><FOOTNOTE>In this JavaScript adaptation, we choose
      to draw primitive objects directly inside of the boxes of the pairs that contain
      them, in an attempt to be consistent with a similar practice introduced in
      section \ref{sec:environment-model}. The box-and-pointer diagrams
      in the original version of the textbook include separate boxes for primitive
      objects, such as 1 and 2, each containing a representation of the object.</FOOTNOTE></div><div class='footnote'>
<a class='footnote-number' id='footnote-2' href='#footnote-link-2'>[2] </a><FOOTNOTE>The use of the word 
        
        <QUOTE>closure</QUOTE> here comes from abstract algebra,
        where a set of elements is said to be closed under an operation if
        applying the operation to elements in the set produces an element that
        is again an element of the set.  The Lisp community
        also (unfortunately) uses the word <QUOTE>closure</QUOTE> to describe a totally unrelated
        concept: A closure is an implementation technique for representing
        
	  
	  functions with free names.
	  
	
	We do not use the word <QUOTE>closure</QUOTE> in
        this second sense in this book.</FOOTNOTE></div><div class='footnote'>
<a class='footnote-number' id='footnote-3' href='#footnote-link-3'>[3] </a><FOOTNOTE>The notion that a means of
        
        combination should satisfy closure is a straightforward idea.
        Unfortunately, the data combiners provided in many popular programming
        languages do not satisfy closure, or make closure cumbersome to
        exploit.  In 
        
        Fortran or 
        
        Basic, one typically combines data elements by
        assembling them into arrays—but one cannot form arrays whose
        elements are themselves arrays.  
        
        Pascal and 
        
        C admit structures whose
        elements are structures.  However, this requires that the programmer
        manipulate pointers explicitly, and adhere to the restriction that
        each field of a structure can contain only elements of a prespecified form.
        Unlike
        Lisp with its pairs, these languages have no built-in general-purpose
        glue that makes it easy to manipulate compound data in a uniform way.
        This limitation lies behind Alan 
        
        Perlis's comment in his foreword to
        this book: <QUOTE>In Pascal the plethora of declarable data structures
          induces a specialization within functions that inhibits and penalizes
          casual cooperation.  It is better to have 100 functions operate on one
          data structure than to have 10 functions operate on 10 data
          structures.</QUOTE></FOOTNOTE></div>
</SECTION><div class='nav'>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter2/section1/subsection4.html'>&lt; Previous</a>
</button><div style='flex-grow: 1;'></div>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a class='scroll-next' href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter2/section2/subsection1.html'>Next &gt;</a>
</button></div><div class='chapter_sign'>
2.2  Hierarchical Data and the Closure Property</div>	<div class='next-page'></div></div>