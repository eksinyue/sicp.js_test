<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>1.3.4 
    Functions
    as Returned Values
  </a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SECTION'><SUBSECTION>

  
  
  

  <div class='permalink'>
<a name='p1' class='permalink'></a><p>
    The above examples demonstrate how
    the ability to pass
    functions
    as arguments significantly enhances
    the expressive power of our programming language.  We can achieve even
    more expressive power by creating
    functions
    whose returned values are
    themselves
    functions.
  </p></div>

  <div class='permalink'>
<a name='p2' class='permalink'></a><p>
    We can illustrate this idea by looking again at the fixed-point
    example described at the end of
    section~\ref{sec:proc-general-methods}.  We formulated a new version
    of the square-root
    function
    as a fixed-point search, starting with
    the observation that $\sqrt{x}$ is a fixed-point of the function
    $y\mapsto x/y$.  Then we used average damping to make the
    approximations converge.  Average damping is a useful general
    technique in itself.  Namely, given a function~$f$, we consider the
    function whose value at $x$ is equal to the average of $x$ and $f(x)$.
  </p></div>
  
  <div class='permalink'>
<a name='p3' class='permalink'></a><p>
    We can express the idea of average damping by means of the
    following
    function:
    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function average_damp(f) {
    return x => average(x, f(x));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAQwG4FMBOyDm6D6AJsgLYAOAFMAJSIDeAUIs4pulCJkgB6IC8APhQZseCtwA0iYOOrUA3AwC+QA}{\usebox\lstbox}


  </p></div>

  <div class='permalink'>
<a name='p4' class='permalink'></a><p>
    
      
      
        The function
        {\lstinline[mathescape=true]$average_damp$}
      
    
    is a
    function
    that takes as its argument a
    function
    {\lstinline[mathescape=true]$f$} and returns as its value a
    function
    (produced by the 
    function definition expression) that, when applied to a number {\lstinline[mathescape=true]$x$}, produces the
    average of {\lstinline[mathescape=true]$x$} and 
    {\lstinline[mathescape=true]$f(x)$}.  
    For example, applying 
    
      
      
        {\lstinline[mathescape=true]$average_damp$}
      
    
    to the {\lstinline[mathescape=true]$square$}
    function
    produces a
    function
    whose
    value at some number $x$ is the average of 
    $x$ and $x^2$.  
    Applying this resulting
    function
    to 10 returns the average of 10 and 100, or
    55:<a class='superscript' id='footnote-1' href='#footnote-1'>[1]</a>
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
average_damp(square)(10);
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=IYNwpgTsDmYPoBNgFsAOAKAzgRwK7AjAEp0BGABiIG4g}{\usebox\lstbox}


  
    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
average_damp(square)(10);
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=IYNwpgTsDmYPoBNgFsAOAKAzgRwK7AjAEp0BGABiIG4g}{\usebox\lstbox}


  </p></div>

  <div class='permalink'>
<a name='p5' class='permalink'></a><p>
    
    Using 
    {\lstinline[mathescape=true]$average_damp$},
    we can reformulate the square-root
    function
    as follows:

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sqrt(x) {
    return fixed_point(average_damp(y => x / y),
                       1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZwI4CcoAoAeBKRAbwChEzF0BTKEdJYGHSgEwH0AHOGMbAQwDdK6XgHNKrZrwC27LAE9EAXgB8iHIgD0iOXgA0pcoaPHDARgB0ABjwBuYgF8gA}{\usebox\lstbox}


    

  </p></div>

  <div class='permalink'>
<a name='p6' class='permalink'></a><p>
    Notice how this formulation makes explicit the three ideas in the
    method: fixed-point search, average damping, and the function
    $y\mapsto x/y$.  It is instructive to compare this formulation of the
    square-root method with the original version given in
    section~\ref{sec:sqrt}.  Bear in mind that these
    functions
    express
    the same process, and notice how much clearer the idea becomes when we
    express the process in terms of these abstractions.  In general, there
    are many ways to formulate a process as a
    function.  Experienced
    programmers know how to choose process formulations that are
    particularly perspicuous, and where useful elements of the process are
    exposed as separate entities that can be reused in other applications.
    As a simple example of reuse, notice that the cube root of $x$ is a
    fixed point of the function $y\mapsto x/y^2$, so we can immediately
    generalize our square-root
    function
    to one that extracts 
    
    
    cube
    roots:<a class='superscript' id='footnote-2' href='#footnote-2'>[2]</a>
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function cube_root(x) {
    return fixed_point(average_damp(y => x / square(y)),
                       1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABBEAjApgfQE5zlACgA8BKRAbwChEbFt0oRslgYj0ATTABzhjEIBDAG7psggOZYOggLbcCAT0QBeAHyIiiAPSIAzgEcQg+kpIkANNVo3bdmwEYAdAAYSAbkoBfIA}{\usebox\lstbox}



    

    
  

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function cube_root(x) {
    return fixed_point(average_damp(y => x / square(y)),
                       1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABBEAjApgfQE5zlACgA8BKRAbwChEbFt0oRslgYj0ATTABzhjEIBDAG7psggOZYOggLbcCAT0QBeAHyIiiAPSIAzgEcQg+kpIkANNVo3bdmwEYAdAAYSAbkoBfIA}{\usebox\lstbox}



    

    
  </p></div>

  \subsubsection{
    Newton's method
  

  <div class='permalink'>
<a name='p7' class='permalink'></a><p>
    
    When we first introduced the square-root
    function, in
    section~\ref{sec:sqrt}, we mentioned that this was a special case of
    <EM>Newton's method</EM>.  
    If $x\mapsto g(x)$ is a differentiable function, then a solution of
    the equation $g(x)=0$ is a fixed point of the function $x\mapsto f(x)$
    where
    
      \[
      f(x) = x - \frac{g(x)}{Dg(x)}
      \]
    
    and
    $Dg(x)$ is the derivative of $g$ evaluated at $x$.  
    
    Newton's
    method is the use of the fixed-point method we saw above to
    approximate a solution of the equation by finding a fixed point of
    the function $f$.<a class='superscript' id='footnote-3' href='#footnote-3'>[3]</a>$g$ and for sufficiently good initial guesses for
    $x$, Newton's method converges very rapidly to a solution of
    $g(x)=0$.<a class='superscript' id='footnote-4' href='#footnote-4'>[4]</a>
  
    For many functions $g$ and for sufficiently good initial guesses for
    $x$, Newton's method converges very rapidly to a solution of
    $g(x)=0$.<a class='superscript' id='footnote-5' href='#footnote-5'>[5]</a>
  </p></div>

  <div class='permalink'>
<a name='p8' class='permalink'></a><p>
    
    
    
    In order to implement Newton's method as a
    function, we must first
    express the idea of derivative.  Note that <QUOTE>derivative,</QUOTE> like
    average damping, is something that transforms a function into another
    function.  For instance, the derivative of the function $x\mapsto
    x^3$ is the function $x \mapsto 3x^2$.  In general, if $g$ is a
    function and $dx$ is a small number, then the derivative $Dg$ of $g$ is
    the function whose value at any number $x$ is given (in the limit of
    small $dx$) by
    
      \[Dg(x) = \frac {g(x+dx) - g(x)}{dx} \]
    
    Thus, we can express the idea of derivative (taking $dx$ to be, say,
    0.00001) as the
    function

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function deriv(g) {
    return x => (g(x + dx) - g(x)) / dx;
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAEwKYCcYDcAUBzASkQG8AoRCxdVKEdJAD0QF4A+RfHJgahQaIC0iPFwJEA9HwDcpAL5A}{\usebox\lstbox}



    along with the
    
    declaration

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
const dx = 0.00001;
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=MYewdgzgLgBAJgDxgXhgBgHRu2gjAbiA}{\usebox\lstbox}


  </p></div>

  <div class='permalink'>
<a name='p9' class='permalink'></a><p>
    
    Like 
    {\lstinline[mathescape=true]$average_damp$},
    {\lstinline[mathescape=true]$deriv$} is a
    function
    that takes a
    function
    as argument and returns a
    function
    as value.  For example,
    to approximate the derivative of $x \mapsto x^3$ at 5 (whose exact
    value is 75) we can evaluate

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function cube(x) { return x * x * x; }

deriv(cube)(5);
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABBEAjApgCgB4EpEDeiATulCMUtogFSLV3YDciAvgFDsAm6xMAbphQZcmAKy4mQA}{\usebox\lstbox}


    
  </p></div>

  <div class='permalink'>
<a name='p10' class='permalink'></a><p>
    With the aid of {\lstinline[mathescape=true]$deriv$}, we can express Newton's method as a
    fixed-point process:

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function newton_transform(g) {
   return x => x - g(x) / deriv(g)(x);
}
function newtons_method(g, guess) {
   return fixed_point(newton_transform(g), guess);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABGApgdygg+lATgQzAGdg5cBbACgHMBKRAbwChFXcUoRckAPRAXgB8iPgFpE1Sj3oB6RABMUuGADcatKbQDcTAL5NQkWAmTpMxLOQ4ALOPJoAaCSBREi9Zq0TtO3RMBgeFHksAAc4GDAoSlQMbDxCEjIqOidqFzdtPSA}{\usebox\lstbox}


    
    
  </p></div>
  <div class='permalink'>
<a name='p11' class='permalink'></a><p>
    The {\lstinline[mathescape=true]$newton_transform$}
    function
    expresses the formula at the
    beginning of this section, and {\lstinline[mathescape=true]$newtons_method$} is readily defined
    in terms of this.  It takes as arguments a
    function
    that computes the
    function for which we want to find a zero, together with an initial
    guess.  For instance, to find the 
    
    square root of $x$, we can use
    Newton's method to find a zero of the function $y\mapsto y^2-x$ starting with
    an initial guess of 1.<a class='superscript' id='footnote-6' href='#footnote-6'>[6]</a>function:

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sqrt(x) {
    return newtons_method(y => square(y) - x,
                          1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZwI4CcoAoAeBKRAbwChEzF0BTKEdJMSgdygWQH0BbagCzgBMsAT0QBeAHwpUIAIZUhBALSIcAGlLkNmrdoCMAOgAMeANzEAvkA}{\usebox\lstbox}


    
    
    
  
    This provides yet another form of the square-root
    function:

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sqrt(x) {
    return newtons_method(y => square(y) - x,
                          1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZwI4CcoAoAeBKRAbwChEzF0BTKEdJMSgdygWQH0BbagCzgBMsAT0QBeAHwpUIAIZUhBALSIcAGlLkNmrdoCMAOgAMeANzEAvkA}{\usebox\lstbox}


    
    
    
  </p></div>

  \subsubsection{
    Abstractions and first-class
    functions
  

  <div class='permalink'>
<a name='p12' class='permalink'></a><p>
    We've seen two ways to express the square-root
    computation as an instance of a more general method, once as a fixed-point
    search and once using Newton's method.  Since Newton's method
    was itself expressed as a fixed-point process,
    we actually saw two ways to compute square roots as fixed points.
    Each method begins with a function and finds a 
    
    fixed
    point of some transformation of the function.  We can express this
    general idea itself as a
    function:

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function fixed_point_of_transform(g, transform, guess) {
    return fixed_point(transform(g), guess);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABMGAPApgEwPoAc4xhTZzDZQBOAhmAM7BwUC2AFAOYA0ilN9jTXNiHS1aASkQBvAFCI5iCuiggKSFBhz5CUFjzoNm7MYOGixAbmkBfIA}{\usebox\lstbox}


    
  </p></div>

  <div class='permalink'>
<a name='p13' class='permalink'></a><p>
    This very general
    function
    takes as its arguments a
    function
    {\lstinline[mathescape=true]$g$}
    that computes some function, a
    function
    that transforms {\lstinline[mathescape=true]$g$}, and
    an initial guess.  The returned result is a fixed point of the
    transformed function.
  </p></div>

  <div class='permalink'>
<a name='p14' class='permalink'></a><p>
    
    Using this abstraction, we can recast the first square-root
    computation from this section (where we look for
    a fixed point of the average-damped version of $y \mapsto x/y$)
    as an instance of this general method:

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sqrt(x) {
    return fixed_point_of_transform(
               y => x / y,
               average_damp,
               1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZwI4CcoAoAeBKRAbwChEzF0BTKEdJYGHSgEwH0AHOGMKVuYVlHQBDMMmBx0AWyyly8hWQCeiALwA+RDkQB6REoA0cxSeEA3SiIDmlVs2FT2Rky4CMAOgAMeANzEAvkA}{\usebox\lstbox}


    
    
  </p></div>

  <div class='permalink'>
<a name='p15' class='permalink'></a><p>
    
    Similarly, we can express the second square-root computation from this section
    (an instance
    of Newton's method that finds a fixed point of the
    Newton transform of $y\mapsto y^2-x$) as

    
    
    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sqrt(x) {
    return fixed_point_of_transform(
               y => square(y) - x,
               newton_transform,
               1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZwI4CcoAoAeBKRAbwChEzF0BTKEdJYGHSgEwH0AHOGMKVuYVlHQBDMMmBx0AWyyly8hWQCeiALwA+FKhDCqWJQQC0iHABo5iy2EoB3KAkEixE6ecvuAjADoADHgDcxAC+QA}{\usebox\lstbox}



    

  </p></div>

  <div class='permalink'>
<a name='p16' class='permalink'></a><p>
    We began section~\ref{sec:higher-order-procedures} with the observation
    that compound
    functions
    are a crucial abstraction mechanism, because they permit us to
    express general methods of computing as explicit elements in our
    programming language.  Now we've seen how higher-order
    functions
    permit us to manipulate these general methods
    to create further abstractions.
  </p></div>
  
  <div class='permalink'>
<a name='p17' class='permalink'></a><p>
    As programmers, we should be alert to opportunities to identify the
    underlying abstractions in our programs and to build upon them and
    generalize them to create more powerful abstractions.  This is not to
    say that one should always write programs in the most abstract way
    possible; expert programmers know how to choose the level of
    abstraction appropriate to their task.  But it is important to be able
    to think in terms of these abstractions, so that we can be ready to
    apply them in new contexts.  The significance of higher-order
    functions
    is that they enable us to represent these abstractions
    explicitly as elements in our programming language, so that they can
    be handled just like other computational elements.
  </p></div>

  <div class='permalink'>
<a name='p18' class='permalink'></a><p>
    In general, programming languages impose restrictions on the ways in
    which computational elements can be manipulated.  Elements with the
    fewest restrictions are said to have 
    
    <EM>first-class</EM> status.  Some
    of the <QUOTE>rights and privileges</QUOTE> of first-class 
    elements are:<a class='superscript' id='footnote-7' href='#footnote-7'>[7]</a><UL>
      <LI>
	
	  
	  They may be referred to using names.
	
      </LI>
      <LI>They may be passed as arguments to
      functions.
      </LI>
      <LI>They may be returned as the results of
      functions.
      </LI>
      <LI>They may be included in data structures.<a class='superscript' id='footnote-8' href='#footnote-8'>[8]</a>
      </LI>
    <hr><div class='footnote'>
<a class='footnote-number' id='footnote-8' href='#footnote-link-8'>[8] </a><FOOTNOTE>We'll see
      examples of this after we introduce data structures in chapter~2.</FOOTNOTE></div></UL>
  
    <UL>
      <LI>
	
	  
	  They may be referred to using names.
	
      </LI>
      <LI>They may be passed as arguments to
      functions.
      </LI>
      <LI>They may be returned as the results of
      functions.
      </LI>
      <LI>They may be included in data structures.<a class='superscript' id='footnote-9' href='#footnote-9'>[9]</a>
      </LI>
    <hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>We'll see
      examples of this after we introduce data structures in chapter~2.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-9' href='#footnote-link-9'>[9] </a><FOOTNOTE>We'll see
      examples of this after we introduce data structures in chapter~2.</FOOTNOTE></div></UL>
  </p></div>
  
  <div class='permalink'>
<a name='p19' class='permalink'></a><p>
    
    
    JavaScript, 
    unlike other common programming languages, awards
    functions
    full first-class status.  This poses challenges for efficient
    implementation, but the resulting gain in expressive power is
    enormous.<a class='superscript' id='footnote-10' href='#footnote-10'>[10]</a>
  </p></div>

  
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled14}
             
    
    Declare a function
    {\lstinline[mathescape=true]$cubic$} that can be used together with the 
    {\lstinline[mathescape=true]$newtons_method$}
    function
    in expressions of the form

    

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
newtons_method(cubic(a, b, c), 1);
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=HYUw7gLg9sDOD6BbEEAWUAmAKAxgVwCMBLHLAQwBoACA6nASmoEZ6BuIA}{\usebox\lstbox}



    to approximate zeros of the cubic $x^3 +ax^2 +bx +c$.
    
  \hfill{\hyperref[ex:unlabeled14-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled14}]

      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function cubic(a, b, c) {
    return x => cube(x) + a * square(x) + b * x + c;
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABBEAjGEAUBDANI1fCASkQG8AoRaxAJwFMoRakAPRAXgD5k17NWpANSJsiAFSIAzgEcQ2BgOEEJidiIgBuCgF8gA}{\usebox\lstbox}



      
      
    
\end{Answer}


  
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled15}

    
    Declare a function
    {\lstinline[mathescape=true]$double$} that takes a
    function
    of one
    argument as argument and
    returns a
    function
    that applies the original
    function
    twice.  For
    example, if {\lstinline[mathescape=true]$inc$} is a
    function
    that adds 1 to its argument,
    then
    
      
      
	{\lstinline[mathescape=true]$double(inc)$}
      
    
    should be a
    function
    that adds 2.  What
    value is returned by

    

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
double(double(double))(inc)(5); // ?
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=CYewrgRgNgpgFKSsHmjAlOuBLAdgYywFZ0BuAAgHpLyB+IA}{\usebox\lstbox}


    
  \hfill{\hyperref[ex:unlabeled15-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled15}]
       
      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function double(f) {
    return x => f(f(x));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAEziARgGwKYApgCUiA3gFCIWIBO2UIVSAHogLwB8iw+ujBBA3KQC+QA}{\usebox\lstbox}



      
      
    
\end{Answer}


  
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

  
  
  Let $f$ and $g$ be two one-argument functions.  The <EM>composition</EM>
  $f$ after $g$ is defined to be the function $x\mapsto f(g(x))$.            
  
  Declare a function
  {\lstinline[mathescape=true]$compose$} that implements composition.  For
  example, if {\lstinline[mathescape=true]$inc$} is a
  function
  that adds 1 to its argument,

  

  
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
compose(square, inc)(6);
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=MYewtgDiDOCmAU0COBXAhgJ1gGgAQEsA7YASngDYSBuIA}{\usebox\lstbox}


  returns 49.
  
  \hfill{\hyperref[ex:compose-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:compose}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function compose(f, g) {
    return x => f(g(x));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABBOBbADnAzgUwBTAA0iA5gJSIDeAUInYgE45QgNIAeiAvAHyLB4SedmTIBuagF8gA}{\usebox\lstbox}



    
    
  
\end{Answer}


  
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
 
    
    If $f$ is a numerical function and $n$ is a positive integer, then we
    can form the $n$th repeated application of $f$, which is defined to be
    the function whose value at $x$ is
    $f(f(\ldots(f(x))\ldots))$.  For
    example, if $f$ is the function
    $x \mapsto x+1$,
    then the $n$th repeated application of
    $f$ is
    the function $x \mapsto x+n$.
    If $f$ is the operation of
    squaring a number, then the $n$th repeated application of
    $f$ is the
    function that raises its argument to the $2^n$th power.  Write a
    function
    that takes as inputs a
    function
    that computes $f$ and a
    positive integer $n$ and returns the
    function
    that computes the $n$th
    repeated application of $f$.  Your
    function
    should be able to be used
    as follows:

    

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
repeated(square, 2)(5);
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=E4UwDiCGAuICYAoDOBHArpUAaABAJgEoEBWAgbiA}{\usebox\lstbox}



    Hint: You may find it convenient to use {\lstinline[mathescape=true]$compose$} from
    exercise~\ref{ex:compose}.
    
    
  \hfill{\hyperref[ex:repeated-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:repeated}]

      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function repeated(f, n) {
    return n === 0
           ? x => x
           : compose(f, repeated(f, n - 1));
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAJwKYAdUEMqoCYAUwANImAJSIDeAUIvSqlCMkkgLyeIAMdD-DAPyIAHonYA+UXwH8AXIghwAtujgBnVEVJpMOfNrKIAtIgCM5cgG4aAXyA}{\usebox\lstbox}



      
      
    
\end{Answer}


  
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
 
  
  
  
  The idea of <EM>smoothing</EM> a function is an important concept in
  signal processing.  If $f$ is a function and
  $dx$ is some small number,
  then the smoothed version of $f$ is the function whose value at a
  point $x$ is the average of $f(x-dx)$,
  $f(x)$, and $f(x+dx)$.  Write a
  function
  {\lstinline[mathescape=true]$smooth$} that takes as input a
  function
  that computes
  $f$ and returns a
  function
  that computes the smoothed $f$.  It is
  sometimes valuable to repeatedly smooth a function (that is, smooth
  the smoothed function, and so on) to obtained the <EM>$n$-fold
  smoothed function</EM>.  Show how to generate the
  $n$-fold smoothed
  function of any given function using {\lstinline[mathescape=true]$smooth$} and
  {\lstinline[mathescape=true]$repeated$} from exercise~\ref{ex:repeated}.
  
  
  \hfill{\hyperref[ex:smooth-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:smooth}]

    
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
const dx = 0.00001;
function smooth(f) {
    return x => (f(x - dx) + f(x) + f(x + dx)) / 3;
}
function n_fold_smooth(f, n) {
    return repeated(smooth, n)(f);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=MYewdgzgLgBAJgDxgXhgBgHRu2gjAbgCgAzAVzGCgEtwYIBbEEKACwApiBKGAb0JgEwATgFMopIWBhJkAPhgc2SALTwE3ANQxiSzdqUwtiTtwD0MAMxEAviXKUaUsAH1iIADZxnDJqw4AaGDBuPkFhMQkpUQAHEQBDKBE4Nh9mFkDgjk4bIA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}


  
\end{Answer}


  
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}

    We saw in section~\ref{sec:proc-general-methods}
    that attempting to compute square roots by naively finding a
    fixed point of $y\mapsto x/y$ does not converge, and that this can be
    fixed by average damping.  The same method works for finding cube
    roots as fixed points of the average-damped $y\mapsto x/y^2$.
    Unfortunately, the process does not work for 
    
    
    fourth roots—a single
    average damp is not enough to make a fixed-point search for $y\mapsto
    x/y^3$ converge.  On the other hand, if we average damp twice (i.e.,
    use the average damp of the average damp of $y\mapsto x/y^3$) the
    fixed-point search does converge.  Do some experiments to determine
    how many average damps are required to compute 
    
    
    $n$th roots as a
    fixed-point search based upon repeated average damping of $y\mapsto
    x/y^{n-1}$.  Use this to implement a simple
    function
    for computing
    $n$th roots using 
    
    {\lstinline[mathescape=true]$fixed_point$},
     
    
    {\lstinline[mathescape=true]$average_damp$},
    and the {\lstinline[mathescape=true]$repeated$}
    function
    of exercise~\ref{ex:repeated}.
    Assume that any arithmetic operations you need are available as primitives.
    

    

  \hfill{\hyperref[ex:nth-roots-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:nth-roots}]

      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function nth_root(n, x) {
    return fixed_point(repeated(average_damp, 
                                math_floor(math_log2(n)))
                       (y => x / fast_expt(y, n - 1)),
                       1.0);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABGKALA+gJznKAKMAGkQA8BKRAbwChE7FMBTKETJYGExgE3QAc4MFHiZ9GAQyg884gG6NM4gOaN03cQFs+xWvT36DhgxskZgAGxyY8JtOktKATATKvdRj3rwBPRAF4APlJEAHpEYHEAZyh0RhI+fG9iJABaRABGV0J3T090gDoABjIAbmoAXyA}{\usebox\lstbox}


      
    
\end{Answer}


  
\stepcounter{ExerciseDisplayNumber}
\begin{Exercise}
\label{ex:unlabeled16}

    
    
    
    
    Several of the numerical methods described in this chapter are instances
    of an extremely general computational strategy known as <EM>iterative
    improvement</EM>.  Iterative improvement says that, to compute something,
    we start with an initial guess for the answer, test if the guess is
    good enough, and otherwise improve the guess and continue the process
    using the improved guess as the new guess.  Write a
    function
    
    {\lstinline[mathescape=true]$iterative_improve$}
    that takes two
    functions
    as arguments: a method
    for telling whether a guess is good enough and a method for improving
    a guess.
    
    The function {\lstinline[mathescape=true]$iterative_improve$}
     should return as its value a
    function
    that takes a guess as argument and keeps improving the guess
    until it is good enough.  Rewrite the {\lstinline[mathescape=true]$sqrt$}
    function
    of
    section~\ref{sec:sqrt} and the 
    
    {\lstinline[mathescape=true]$fixed_point$}
    
    function
    of
    section~\ref{sec:proc-general-methods} in terms of
    
    {\lstinline[mathescape=true]$iterative_improve$}
    .

    
    
  \hfill{\hyperref[ex:unlabeled16-Answer]{Solution}}\\
\end{Exercise}

\begin{Answer}[ref={ex:unlabeled16}]

      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function iterative_improve(good_enough, improve) {
    function iterate(guess) {
        return good_enough(guess)
               ? guess
               : iterate(improve(guess));
    }
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABDKBTATgQ1gN1QfRgFsAHdOPACgHM44ATfVMOEagCwBplTy8BKRAG8AUInGJQkWAmRosaGiFQBnFYNEStidKigh0SWgyYs27JavVjttiQH5E1ZWpt3bALjkZsqSsTIKP2crfn4AbjdEAF8o3X1DbwVUSOigA}{\usebox\lstbox}!*/
    return iterate;
}

\end{JavaScriptClickable}


      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function sqrt(x) {
    return iterative_improve(y => good_enough(y, x), 
                             y => improve(y, x))(1);
}

sqrt(49);
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=GYVwdgxgLglg9mABAZwI4CcoAoAeBKRAbwChEzF0BTKEdJGKS9AQ1gDdKB9GAWwAd0cDlgCeiALwA+RAHM4cACadKYOCBkALUQBpE+XaXJHjJ0+TFTEvAUMo69ePFgCMeANzEAvsWJpMWABYATncgA}{\usebox\lstbox}



      
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
const tolerance = 0.00001;	  
function fixed_point(f, first_guess) {
    return iterative_improve(
               guess => abs(guess - f(guess)) < tolerance,
               f)
           (first_guess);
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=4&prgrm=MYewdgzgLgBFIBsCmAnAhmYSYF4YAYA6fE-ARgG4BIGGAKADMBXTKAS3BgbYA8kATAPoAHEGzBQAFAwA0XNimiCA5kyQQIAShgBvOrVookUJijAw2UVGnYA3JILYBbYShD3J+g95+1V6iFwAPhg0ACMISX8NGABaLii1DU1tAB44RGtMJBkvX3yGTTz8mGkFJWitCjoAXzpGXgERMQlJJxsAC0FQCDkyYk0KIA}{\usebox\lstbox}!*/
}

fixed_point(math_cos, 1.0);

\end{JavaScriptClickable}


    
\end{Answer}

  
  
<hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>Observe that this is a combination 
    whose operator is itself
    
    
    
    a combination.  Exercise~\ref{ex:a-plus-abs-b} already demonstrated
    the ability to form such combinations, but that was only a toy
    example.  Here we begin to see the real need for such
    combinations—when applying a
    function
    that is obtained as the value
    returned by a higher-order
    function.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>See exercise~\ref{ex:nth-roots} 
    for a further generalization.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>Elementary 
    calculus books usually describe Newton's
    method in terms of the sequence of approximations
    $x_{n+1}=x_n-g(x_n)/Dg(x_n)$.  Having language for talking about
    processes and using the idea of fixed points simplifies the description
    of the method.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>Newton's 
    method does not always converge to an answer, but
    it can be shown that in favorable cases each iteration doubles the
    number-of-digits accuracy of the approximation to the solution.
    In such cases, 
    
    
    Newton's method will converge much more
    rapidly than the half-interval method.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>Newton's 
    method does not always converge to an answer, but
    it can be shown that in favorable cases each iteration doubles the
    number-of-digits accuracy of the approximation to the solution.
    In such cases, 
    
    
    Newton's method will converge much more
    rapidly than the half-interval method.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>For finding square roots, 
    Newton's method converges rapidly to the
    correct solution from any starting point.</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>The notion of first-class status of 
    programming-language 
    elements is due to the British computer scientist Christopher
    Strachey (1916–1975).</FOOTNOTE></div><hr><div class='footnote'>
<a class='footnote-number' id='footnote-10' href='#footnote-link-10'>[10] </a><FOOTNOTE>The major implementation cost of first-class
    functions
    is that allowing
    functions
    to be returned as values
    requires reserving storage for a
    
      
      function's free names
    
    even while the
    function
    is not executing.  
    
      
      In the JavaScript implementation we will
      study in section~\ref{sec:mc-eval}, these names are stored in the function
      
      's environment.</FOOTNOTE></div>
</SUBSECTION>