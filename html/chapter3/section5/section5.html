<div id='permalink-msg'>
<div class='screen'>
	<div class='alert alert-success'>
		<strong>Permalink copied!</strong>
	</div>
</div>
</div>

<div class='chapter-content'>
<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>3.5  Streams</a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SECTION'><SECTION>

    <SECTIONCONTENT></SECTIONCONTENT>

    
    

    <div class='permalink'>
<a name='p1' class='permalink'></a><p>
      We've gained a good understanding of assignment as a tool in modeling,
      as well as an appreciation of the complex problems that assignment
      raises. It is time to ask whether we could have gone about things in a
      different way, so as to avoid some of these problems.  In this
      section, we explore an alternative approach to modeling state, based
      on data structures called <EM>streams</EM>.  As we shall see, streams can
      mitigate some of the complexity of modeling state.
    </p></div>

    <div class='permalink'>
<a name='p2' class='permalink'></a><p>
      Let's step back and review where this complexity comes from.  In an
      attempt to model real-world phenomena, we made some apparently
      reasonable decisions: We modeled real-world objects with local state
      by computational objects with local variables.  We identified time
      variation in the real world with time variation in the computer.  We
      implemented the time variation of the states of the model objects in
      the computer with assignments to the local variables of the model
      objects.
    </p></div>

    <div class='permalink'>
<a name='p3' class='permalink'></a><p>
      Is there another approach?  Can we avoid identifying time in the
      computer with time in the modeled world?  Must we make the model
      change with time in order to model phenomena in a changing world?
      Think about the issue in terms of mathematical functions.  We can
      describe the time-varying behavior of a quantity $x$ as a function of
      time $x(t)$.  
      If we concentrate on $x$ instant by instant, we think of
      it as a changing quantity.  Yet if we concentrate on the entire
      time history of values, we do not emphasize changeâ€”the function
      itself does not change.<a class='superscript' id='footnote-link-1' href='#footnote-1'>[1]</a>
    </p></div>

    <div class='permalink'>
<a name='p4' class='permalink'></a><p>
      If time is measured in discrete steps, then we can model a time function as
      a (possibly infinite) sequence.  In this section, we will see how to
      model change in terms of sequences that represent the time histories
      of the systems being modeled.  To accomplish this, we introduce new
      data structures called <EM>streams</EM>.  From an abstract point of view,
      a stream is simply a sequence.  However, we will find that the
      straightforward implementation of streams as lists (as in
      section \ref{sec:sequences}) doesn't fully reveal
      the power of stream processing.  As an alternative, we introduce the
      technique of 
      
      <EM>delayed evaluation</EM>, which enables us to represent
      very large (even infinite) sequences as streams.
    </p></div>

    <div class='permalink'>
<a name='p5' class='permalink'></a><p>
      Stream processing lets us model systems that have state without ever
      using assignment or mutable data.  This has important implications,
      both theoretical and practical, because we can build models that avoid
      the drawbacks inherent in introducing assignment.  On the other hand,
      the stream framework raises difficulties of its own, and the question
      of which modeling technique leads to more modular and more easily
      maintained systems remains open.
    </p></div>

    <hr><div class='footnote'>
<a class='footnote-number' id='footnote-1' href='#footnote-link-1'>[1] </a><FOOTNOTE>Physicists sometimes adopt this view by introducing the
        
        <QUOTE>world lines</QUOTE> of particles as a device for reasoning about motion.
        We've also already mentioned
        (section \ref{sec:sequences-conventional-interfaces}) that this is the
        natural way to think about signal-processing systems.  We will explore
        applications of streams to signal processing in
        section \ref{sec:exploiting-streams}.</FOOTNOTE></div>
</SECTION><div class='nav'>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter3/section4/subsection2.html'>&lt; Previous</a>
</button><div style='flex-grow: 1;'></div>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a class='scroll-next' href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter3/section5/subsection1.html'>Next &gt;</a>
</button></div><div class='chapter_sign'>
3.5  Streams</div>	<div class='next-page'></div></div>