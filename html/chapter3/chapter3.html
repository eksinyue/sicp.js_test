<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>3 Modularity, Objects, and State</a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SECTION'><CHAPTER>

  

  \epigraph{
    $\def\aal{\alpha{\raise 1pt\hbox{\hskip -4pt{\char'47}}}}M\epsilon\tau\alpha\beta\acute{\alpha}\lambda\lambda o \nu\
    ἀ\nu\alpha\pi\alpha\acute{\upsilon}\epsilon\tau\alpha\iota$
    
\noindent 
    (Even while it changes, it stands still.)
    
    }{--- \textup{Heraclitus}}

  \epigraph{
    Plus Ça change, plus c'est la même chose.

    
    }{--- \textup{Alphonse Karr}}


  

  <div class='permalink'>
<a name='p1' class='permalink'></a><p>
    The preceding chapters introduced the basic elements from which
    programs are made.  We saw how primitive
    functions
    and primitive data
    are combined to construct compound entities, and we learned that
    abstraction is vital in helping us to cope with the complexity of
    large systems.  But these tools are not sufficient for designing
    programs.  Effective program synthesis also requires organizational
    principles that can guide us in formulating the overall design of a
    program.  In particular, we need strategies to help us structure large
    systems so that they will be <EM>modular</EM>, that is, so that they can
    be divided <QUOTE>naturally</QUOTE> into coherent parts that can be separately
    developed and maintained.
  </p></div>

  <div class='permalink'>
<a name='p2' class='permalink'></a><p>
    
    
    One powerful design strategy, which is particularly appropriate to the
    construction of programs for modeling physical systems, is to base the
    structure of our programs on the structure of the system being
    modeled.  For each object in the system, we construct a corresponding
    computational object.  For each system action, we define a symbolic
    operation in our computational model.  Our hope in using this strategy
    is that extending the model to accommodate new objects or new actions
    will require no strategic changes to the program, only the addition of
    the new symbolic analogs of those objects or actions.  If we have been
    successful in our system organization, then to add a new feature or
    debug an old one we will have to work on only a localized part of the
    system.
  </p></div>

  <div class='permalink'>
<a name='p3' class='permalink'></a><p>
    To a large extent, then, the way we organize a large program is
    dictated by our perception of the system to be modeled.  In this
    chapter we will investigate two prominent organizational strategies
    arising from two rather different <QUOTE>world views</QUOTE> of the structure of
    systems.  The first organizational strategy concentrates on
    
    <EM>
      objects</EM>, viewing a large system as a collection of distinct objects
    whose behaviors may change over time.  An alternative organizational
    strategy concentrates on the
    
    <EM>streams</EM> of information that flow in
    the system, much as an electrical engineer views a signal-processing
    system.
  </p></div>

  <div class='permalink'>
<a name='p4' class='permalink'></a><p>
    Both the object-based approach and the stream-processing approach
    raise significant linguistic issues in programming.
    With objects, we must be concerned with how a computational object can
    change and yet maintain its identity.  This will force us to abandon
    our old substitution model of computation
    (section~\ref{sec:substitution-model}) in favor of a more mechanistic
    but less theoretically tractable
    
    <EM>environment model</EM> of
    computation.  The difficulties of dealing with objects, change, and
    identity are a fundamental consequence of the need to grapple with
    time in our computational models.  These difficulties become even
    greater when we allow the possibility of concurrent execution of
    programs.  The stream approach can be most fully exploited when we
    decouple simulated time in our model from the order of the events that
    take place in the computer during evaluation.  We will accomplish this
    using a technique known as
    
    <EM>delayed evaluation</EM>.
  </p></div>

  

  
  &section3.1;

  
  &section3.2;

  
  &section3.3;

  
  &section3.4;

  
  &section3.5;


</CHAPTER>