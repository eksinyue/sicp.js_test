<div id='permalink-msg'>
<div class='screen'>
	<div class='alert alert-success'>
		<strong>Permalink copied!</strong>
	</div>
</div>
</div>

<div class='chapter-content'>
<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>5.3  Storage Allocation and Garbage Collection</a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SECTION'><SECTION>

    <SECTIONCONTENT></SECTIONCONTENT>

    
    
    

    <div class='permalink'>
<a name='p1' class='permalink'></a><p>
      In section \ref{sec:eceval}, we will show how to implement a
      JavaScript      
      evaluator as a register machine.  In order to simplify the discussion,
      we will assume that our register machines can be equipped with a <EM>
  list-structured memory</EM>, in which the basic operations for
      manipulating list-structured data are primitive.  Postulating the
      existence of such a memory is a useful abstraction when one is
      focusing on the mechanisms of control in a
      JavaScript
      interpreter, but this does not reflect a realistic view of the actual primitive data
      operations of contemporary computers.  To obtain a more complete
      picture of how a JavaScript system operates, we must investigate how list
      structure can be represented in a way that is compatible with
      conventional computer memories.
    </p></div>

    <div class='permalink'>
<a name='p2' class='permalink'></a><p>
      There are two considerations in implementing list structure.  The
      first is purely an issue of representation: how to represent the
      <QUOTE>box-and-pointer</QUOTE> structure of JavaScript pairs, using only the storage
      and addressing capabilities of typical computer memories.  The second
      issue concerns the management of memory as a computation proceeds.
      The operation of a JavaScript system depends crucially on the ability to
      continually create new data objects.  These include objects that are
      explicitly created by the JavaScript
      functions
      being interpreted as well
      as structures created by the interpreter itself, such as environments
      and argument lists.  Although the constant creation of new data
      objects would pose no problem on a computer with an infinite amount of
      rapidly addressable memory, computer memories are available only in
      finite sizes (more's the pity).  JavaScript systems
      thus provide an 
      
      <EM>automatic storage allocation</EM> facility to
      support the illusion of an infinite memory.  When a data object is no
      longer needed, the memory allocated to it is automatically recycled
      and used to construct new data objects.  There are various
      techniques for providing such automatic storage allocation.  The
      method we shall discuss in this section is called <EM>garbage
  collection</EM>.
    </p></div>

    
</SECTION><div class='nav'>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter5/section2/subsection4.html'>&lt; Previous</a>
</button><div style='flex-grow: 1;'></div>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a class='scroll-next' href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter5/section3/subsection1.html'>Next &gt;</a>
</button></div><div class='chapter_sign'>
5.3  Storage Allocation and Garbage Collection</div>	<div class='next-page'></div></div>