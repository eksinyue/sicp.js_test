<div id='permalink-msg'>
<div class='screen'>
	<div class='alert alert-success'>
		<strong>Permalink copied!</strong>
	</div>
</div>
</div>

<div class='chapter-content'>
<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>5  Computing with Register Machines</a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SECTION'><CHAPTER>

  

  <blockquote class='blockquote'>

    My aim is to show that the heavenly machine is not a kind of divine,
    live being, but a kind of clockwork (and he who believes that a clock
    has soul attributes the maker's glory to the work), insofar as nearly
    all the manifold motions are caused by a most simple and material
    force, just as all motions of the clock are caused by a single weight.

    
    <div class='chapter-text-ATTRIBUTION'>
<span class='chapter-text-AUTHOR'>Johannes Kepler</span>
<span class='chapter-text-DATE'>(letter to Herwart von Hohenburg, 1605)</span>
</div>
</blockquote>


  

  <div class='permalink'>
<a name='p1' class='permalink'></a><p>
    We began this book by studying processes and by describing processes
    in terms of
    functions
    written in JavaScript.  To explain the meanings of
    these
    functions, we used a succession of models of evaluation: the
    substitution model of chapter 1, the environment model of chapter 3,
    and the metacircular evaluator of chapter 4.  Our examination of the
    metacircular evaluator, in particular, dispelled much of the mystery
    of how JavaScript-like languages are interpreted.
    But even the metacircular evaluator leaves important questions
    unanswered, because it fails to elucidate the mechanisms of control in
    a JavaScript system.  For instance, the evaluator does not explain how the
    evaluation of a subexpression manages to return a value to the
    expression that uses this value, nor does the evaluator explain how
    some recursive
    functions
    generate iterative processes (that is, are evaluated
    using constant space) whereas other recursive
    functions
    generate recursive
    processes.  These questions remain unanswered because the metacircular
    evaluator is itself a JavaScript program and hence inherits the control
    structure of the underlying JavaScript system.  In order to provide a more
    complete description of the control structure of the JavaScript evaluator,
    we must work at a more primitive level than JavaScript itself.
  </p></div>

  <div class='permalink'>
<a name='p2' class='permalink'></a><p>
    In this chapter we will describe processes in terms of the step-by-step
    operation of a traditional computer.  Such a computer, or 
    
    <EM>
      register machine</EM>, sequentially executes 
    <EM>instructions</EM> that
    manipulate the contents of a fixed set of storage elements called 
    
    <EM>
      registers</EM>.  A typical register-machine instruction applies a
    primitive operation to the contents of some registers and assigns the
    result to another register.  Our descriptions of processes executed by
    register machines will look very much like <QUOTE>machine-language</QUOTE>
    programs for traditional computers.  However, instead of focusing on
    the machine language of any particular computer, we will examine
    several JavaScript
    functions
    and design a specific register machine to
    execute each
    function.  Thus, we will approach our task from the
    perspective of a hardware architect rather than that of a
    machine-language computer programmer.  In designing register machines,
    we will develop mechanisms for implementing important programming
    constructs such as recursion.  We will also present a language for
    describing designs for register machines.  In
    section \ref{sec:simulator} we will
    implement a JavaScript program that
    uses these descriptions to simulate the machines we design.
  </p></div>

  <div class='permalink'>
<a name='p3' class='permalink'></a><p>
    Most of the primitive operations of our register machines are very
    simple.  For example, an operation might add the numbers fetched from
    two registers, producing a result to be stored into a third register.
    Such an operation can be performed by easily described hardware.  In
    order to deal with list structure, however, we will also use the
    memory operations <kbd>head</kbd>, <kbd>tail</kbd>, and <kbd>pair</kbd>, which require
    an elaborate storage-allocation mechanism.  In
    section \ref{sec:storage-allocation} we study their implementation in
    terms of more elementary operations.
  </p></div>

  <div class='permalink'>
<a name='p4' class='permalink'></a><p>
    In section \ref{sec:eceval}, after we have accumulated experience
    formulating simple
    functions
    as register machines, we will design a
    machine that carries out the algorithm described by the metacircular
    evaluator of section \ref{sec:mc-eval}.  This will fill in the gap in
    our understanding of how JavaScript programs are interpreted, by
    providing an explicit model for the mechanisms of control in the
    evaluator.
    In section \ref{sec:compilation} we will study a simple compiler that
    translates JavaScript programs into sequences of instructions that can be
    executed directly with the registers and operations of the evaluator
    register machine.
  </p></div>

  

  
</CHAPTER><div class='nav'>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter4/section4/subsection4.html'>&lt; Previous</a>
</button><div style='flex-grow: 1;'></div>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a class='scroll-next' href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter5/section1/section1.html'>Next &gt;</a>
</button></div><div class='chapter_sign'>
5  Computing with Register Machines</div>	<div class='next-page'></div></div>