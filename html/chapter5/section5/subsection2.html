<div id='permalink-msg'>
<div class='screen'>
	<div class='alert alert-success'>
		<strong>Permalink copied!</strong>
	</div>
</div>
</div>

<div class='chapter-content'>
<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>5.5.2  Compiling Expressions</a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SUBSECTION'><SUBSECTION>

      <div class='permalink'>
<a name='p1' class='permalink'></a><p>
  In this section and the next we implement the code generators to which the <kbd>compile</kbd>
  function
  dispatches.
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  Compiling linkage code
      </h2></div>

      <div class='permalink'>
<a name='p2' class='permalink'></a><p>
  
  In general, the output of each code generator will end with
  instructions—generated by the
  function
  <kbd>compile_linkage</kbd>—that
  implement the required linkage.  If the linkage is <kbd>return</kbd> then
  we must generate the instruction <kbd>go_to(reg("continue"))</kbd>.  This
  needs the <kbd>continue</kbd> register and does not modify any registers.
  If the linkage is <kbd>next</kbd>, then we needn't include any additional
  instructions.  Otherwise, the linkage is a label, and we generate a
  <kbd>go_to</kbd> to that label, an instruction that does not need or modify
  any registers.<a class='superscript' id='footnote-link-1' href='#footnote-1'>[1]</a>
      </p></div>

      <div class='permalink'>
<a name='p3' class='permalink'></a><p>
  For example, if the value of <kbd>linkage</kbd> is the <SPLIT>string</SPLIT>
  <kbd>"branch25"</kbd>, then the expression
  <kbd>go_to(label(linkage))</kbd>
  evaluates to the list
  <kbd>go_to(label("branch25"))</kbd>.
  Similarly, if the value of <kbd>x</kbd> is the list <kbd>list("a", "b", "c")</kbd>, then
  <kbd>list(1, 2, head(x))</kbd>
  evaluates to the list
  <kbd>list(1, 2, "a")</kbd>.

  <div class='snippet' id='javascript_115_1_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function compile_linkage(linkage) {
    return linkage === "return"
        ? make_instruction_sequence(list("continue"), list(), list(go_to(reg("continue"))))
        : linkage === "next"
        ? empty_instruction_sequence()
        : make_instruction_sequence(list(), list(), list(go_to(label(linkage))));
}
</pre></div></div>
      </p></div>

      <div class='permalink'>
<a name='p4' class='permalink'></a><p>
  The linkage code is appended to an instruction sequence by <kbd>preserving</kbd>
  the <kbd>continue</kbd> register, since a <kbd>return</kbd> linkage will
  require the <kbd>continue</kbd> register:
  If the given instruction sequence modifies <kbd>continue</kbd> and the
  linkage code needs it, <kbd>continue</kbd> will be saved and restored.

  <div class='snippet' id='javascript_115_2_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function end_with_linkage(linkage, instruction_sequence) {
    return preserving(list("continue"), instruction_sequence, compile_linkage(linkage));
}
</pre></div></div>
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  Compiling simple expressions
      </h2></div>

      <div class='permalink'>
<a name='p5' class='permalink'></a><p>
  
  
  
  The code generators for self-evaluating expressions,
  quotations, and variables construct instruction
  sequences that assign the required value to the target register
  and then proceed as specified by the linkage descriptor.

  <div class='snippet' id='javascript_115_3_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function compile_self_evaluating(exp, target, linkage) {
        return end_with_linkage(
            linkage,
            make_instruction_sequence(
                list(),
                list(target),
                list(assign(target, constant(exp)))));
    }


    function compile_quoted(exp, target, linkage) {
        return end_with_linkage(
            linkage,
            make_instruction_sequence(
                list(),
                list(target),
                list(assign(target, constant(stringify(exp))))));
    }


    function compile_variable(exp, target, linkage) {
        return end_with_linkage(
            linkage,
            make_instruction_sequence(
                list("env"),
                list(target),
                list(assign(target, op("lookup_variable_value"), constant(exp), reg("env")))));
    }
</pre></div></div>
      </p></div>

      <div class='permalink'>
<a name='p6' class='permalink'></a><p>
  All these assignment instructions modify the target register,
  and the one that looks up a variable needs the <kbd>env</kbd> register.
      </p></div>

      <div class='permalink'>
<a name='p7' class='permalink'></a><p>
  
  
  Assignments and definitions are handled much as they are in the
  interpreter.  We recursively generate code that computes the value to
  be assigned to the variable, and append to it a two-instruction
  sequence that actually sets or defines the variable and assigns the
  value of the whole expression (the symbol <kbd>ok</kbd>) to the target
  register.  The recursive compilation has target <kbd>val</kbd> and linkage
  <kbd>next</kbd> so that the code will put its result into <kbd>val</kbd> and
  continue with the code that is appended after it.  The appending is
  done preserving <kbd>env</kbd>, since the environment is needed for setting
  or defining the variable and the code for the variable value could be
  the compilation of a complex expression that might modify the
  registers in arbitrary ways.

  <div class='snippet' id='javascript_115_4_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function compile_assignment(exp, target, linkage) {
    const variable = assignment_variable(exp);
    const get_value_code = compile(assignment_value(exp), "val", "next");

    return end_with_linkage(
        linkage,
        preserving(
            "env",
            get_value_code,
            make_instruction_sequence(
                list("env", "val"),
                list(target),
                list(
                    perform(
                        op("set_variable_value"),
                        constant(variable),
                        reg("val"),
                        reg("env")),
                    assign(target, constant(ok)))))); /// FIXME: ok??=
}

function compile_definition(exp, target, linkage) {
    const variable = definition_variable(exp);
    const get_value_code = compile(definition_value(exp), "val", "next");

    return end_with_linkage(
        linkage,
        preserving(
            "env",
            get_value_code,
            make_instruction_sequence()
                list("env", "val"),
                list(target),
                list(
                    perform(
                        op("define_variable"),
                        constant(variable),
                        reg("val"),
                        reg("env")),
                    assign(target, constant(ok)))))); /// FIXME: ok??=
}
</pre></div></div>
      </p></div>

      <div class='permalink'>
<a name='p8' class='permalink'></a><p>
  The appended two-instruction sequence requires <kbd>env</kbd> and <kbd>val</kbd>
  and modifies the target.  Note that although we preserve <kbd>env</kbd> for
  this sequence, we do not preserve <kbd>val</kbd>, because the <kbd>get_value_code</kbd> is designed to explicitly place its result in <kbd>val</kbd> for use by this sequence.
  (In fact, if we did preserve <kbd>val</kbd>, we would
  have a bug, because this would cause the previous contents of <kbd>val</kbd> to be restored right after the <kbd>get_value_code</kbd> is run.)
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  Compiling conditional expressions
      </h2></div>

      <div class='permalink'>
<a name='p9' class='permalink'></a><p>
  
  The code for an <kbd>if</kbd> expression
  compiled with a given target and linkage has the form

  <kbd class='snippet'>
    
    
      $\langle \textit{compilation of predicate, target}$ val$\textit{, linkage}$ next $\rangle$
      test(op("is_false"), reg("val")),
          branch(label("false_branch")),
      "true_branch",
      $\langle \textit{compilation of consequent with given target and given linkage or}$ after_if $\rangle$
      "false_branch",
      $\langle \textit{compilation of alternative with given target and linkage} \rangle$
      "after_if",
    
  </kbd>
      </p></div>

      <div class='permalink'>
<a name='p10' class='permalink'></a><p>
  To generate this code, we compile the predicate, consequent,
  and alternative, and combine the resulting code with instructions
  to test the predicate result and with newly generated labels to mark the true and false branches and the end of the 
  conditional.<a class='superscript' id='footnote-link-2' href='#footnote-2'>[2]</a>
  In this arrangement of code, we must branch around the true branch
  if the test is false.  The only slight complication is in how the
  linkage for the true branch should be handled.  If the linkage for the
  conditional is <kbd>return</kbd> or a label, then the true and false
  branches will both use this same linkage.  If the linkage is <kbd>next</kbd>, the true branch ends with a jump around the code for the false
  branch to the label at the end of the conditional.

  <div class='snippet' id='javascript_115_5_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function compile_if(exp, target, linkage) {
    let t_branch = make_label("true_branch");
    let f_branch = make_label("false_branch");
    let after_if = make_label("after_if");
    let consequent_linkage = linkage === "next" ? after_if : linkage;
    let p_code = compile(if_predicate(exp), "val", "next");
    let c_code = compile(if_consequent(exp), target, consequent_linkage);
    let a_code = compile(if_alternative(exp), target, linkage);

    return preserving(list("env", "continue"),
                      p_code,
                      append_instruction_sequences(
                          make_instruction_sequence(list("val"),
                                                    list(),
                                                    list(
                                                        test(op("is_false"), reg("val")),
                                                        branch(label(f_branch)))),
                          parallel_instruction_sequences(
                              append_instruction_sequences(t_branch, c_code),
                              append_instruction_sequences(f_branch, a_code)),
                          after_if));
}
</pre></div></div>
      </p></div>

      <div class='permalink'>
<a name='p11' class='permalink'></a><p>
  <kbd>Env</kbd> is preserved around the predicate code because it could be needed by
  the true and false branches, and <kbd>continue</kbd> is preserved because it could
  be needed by the linkage code in those branches.  The code for the true and
  false branches (which are not executed sequentially) is appended using a
  special combiner <kbd>parallel_instruction_sequences</kbd> described in
  section \ref{sec:combining-instruction-sequences}.
      </p></div>

      <div class='permalink'>
<a name='p12' class='permalink'></a><p>
        <SPLIT>FIXME:</SPLIT>
  Note that <kbd>cond</kbd> is a derived expression, so all that the
  compiler needs to do handle it is to apply the <kbd>cond->if</kbd>
  transformer (from section \ref{sec:representing-expressions}) and
  compile the resulting <kbd>if</kbd> expression.
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  Compiling sequences
      </h2></div>

      <div class='permalink'>
<a name='p13' class='permalink'></a><p>
  
  The compilation of sequences (from
  function
  bodies or explicit <kbd>begin</kbd> expressions) parallels their evaluation.  Each expression of the
  sequence is compiled—the last expression with the linkage specified
  for the sequence, and the other expressions with linkage <kbd>next</kbd>
  (to execute the rest of the sequence).
  The instruction sequences for the individual expressions are appended
  to form a single instruction sequence, such that <kbd>env</kbd> (needed for
  the rest of the sequence) and <kbd>continue</kbd> (possibly needed for the
  linkage at the end of the sequence) are preserved.

  <div class='snippet' id='javascript_115_6_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function compile_sequence(seq, target, linkage) {
    return is_last_exp(seq)
        ? compile(first_exp(seq), target, linkage)
        : preserving(
            list("env", "continue"),
            compile(first_exp("seq"), target, "next"),
            compile_sequence(rest_exps(seq), target, linkage));
}
</pre></div></div>
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  Compiling <kbd>lambda</kbd> expressions
      </h2></div>

      <div class='permalink'>
<a name='p14' class='permalink'></a><p>
  
  Function definition expressions expressions construct
  functions.
  The object code for a function definition expression must have the form

  <kbd class='snippet'>
    
    
$\langle \textit{construct procedure object and assign it to target register} \rangle$
$\langle \textit{linkage} \rangle$
    
  </kbd>
      </p></div>

      <div class='permalink'>
<a name='p15' class='permalink'></a><p>
  When we compile the function definition expression, we also generate the code for the
  function
  body.  Although the body won't be executed at the time of
  function
  construction, it is convenient to insert it into the object code right after
  the code for the function definition.  If the linkage for the function definition expression
  is a label or <kbd>return</kbd>, this is fine.  But if the linkage is <kbd>next</kbd>,
  we will need to skip around the code for the
  function
  body by using a linkage
  that jumps to a label that is inserted after the body.  The object code thus
  has the form

  <kbd class='snippet'>
    
    
$\langle \textit{construct procedure object and assign it to target register}\rangle$
$\langle \textit{code for given linkage}\rangle\ \textit{or}$ go_to(label("after_lambda"))
$\langle \textit{compilation of procedure body} \rangle$
"after_lambda",
    
  </kbd>
      </p></div>

      <div class='permalink'>
<a name='p16' class='permalink'></a><p>
  <kbd>Compile_function_expression</kbd> generates the code for constructing the
  function
  object followed by the code for the
  function
  body.
  The
  function
  object will be constructed at run time by combining
  the current environment (the environment at the point of definition)
  with the entry point to the compiled
  function
  body (a newly generated
  label).<a class='superscript' id='footnote-link-3' href='#footnote-3'>[3]</a>

  <div class='snippet' id='javascript_115_7_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function compile_function_expression(exp, target, linkage) {
    let proc_entry = make_label("entry");
    let after_fexp = make_label("after_lambda"); /// FIXME: lambda
    let lambda_linkage = linkage === "next" ? after_lambda : linkage;

    return append_instruction_sequences(
        tack_on_instruction_sequence(
            end_with_linkage(
                lambda_linkage,
                make_instruction_sequence(
                    list("env"), 
                    list(target),
                    list(assign(target, op("make_compiled_procedure"), label(proc_entry), reg("env")))), 
            compile_function_expression_body(exp, proc_entry)),
            after_lambda));
}
</pre></div></div>
      </p></div>

      <div class='permalink'>
<a name='p17' class='permalink'></a><p>
  <kbd>Compile_function_expression</kbd> uses the special combiner <kbd>tack_on_instruction_sequence</kbd>
  (section \ref{sec:combining-instruction-sequences}) rather than <kbd>append_instruction_sequences</kbd> to append the
  function
  body to the <kbd>lambda</kbd>
  expression code, because the body is not part of the sequence of instructions
  that will be executed when the combined sequence is entered; rather, it is in
  the sequence only because that was a convenient place to put it.
      </p></div>

      <div class='permalink'>
<a name='p18' class='permalink'></a><p>
  <kbd>Compile_lambda_body</kbd> constructs the code for the body of the
  function.  This code begins with a label for the entry point.  Next
  come instructions that will cause the run-time evaluation environment
  to switch to the correct environment for evaluating the
  function
  body—namely, the definition environment of the
  function, extended
  to include the bindings of the formal parameters to the arguments with
  which the
  function
  is called.  After this comes the code for the
  sequence of expressions that makes up the
  function
  body.
  The sequence is compiled with linkage <kbd>return</kbd> and target <kbd>val</kbd>
  so that it will end by returning from the
  function
  with the
  function
  result in <kbd>val</kbd>.

  <div class='snippet' id='javascript_115_8_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function compile_lambda_body(exp, proc_entry) {
    let formals  = lambda_parameters(exp);
    return append_instruction_sequences(
        make_instruction_sequence(
            list("env", "proc", "argl"),
            list("env"),
            list(proc_entry,
                 assign("env", op("compiled_procedure_env"), reg("proc")),
                 assign("env", op("extend_environment"), constant(formals), reg("argl"), reg("env")))),
        compiled_sequence(lambda_body(exp), "val", "return"));
}
</pre></div></div>
      </p></div>

    <hr><div class='footnote'>
<a class='footnote-number' id='footnote-1' href='#footnote-link-1'>[1] </a><FOOTNOTE>This
    function
    uses a feature of JavaScript called <EM>
      
      
      
      
      
      backquote</EM> (or <EM>quasiquote</EM>) that is handy for constructing lists.
    Preceding a list with a backquote symbol is much like quoting it,
    except that anything in the list that is flagged with a comma is evaluated.
  </FOOTNOTE></div><div class='footnote'>
<a class='footnote-number' id='footnote-2' href='#footnote-link-2'>[2] </a><FOOTNOTE>We can't just
    use the labels <kbd>true_branch</kbd>, <kbd>false_branch</kbd>, and
    <kbd>after_if</kbd> as shown above,
    because there might be more than one <kbd>if</kbd> in the program.
    
    The compiler uses the
    function
    <kbd>make_label</kbd> to generate labels.
    <kbd>Make_label</kbd> takes a symbol as argument and returns a new symbol
    that begins with the given symbol.  For example, successive calls to
    <kbd>make_label("a")</kbd> would return <kbd>a1</kbd>, <kbd>a2</kbd>, and so on.
    <kbd>Make_label</kbd> can be implemented similarly to the generation of
    unique variable names in the query language, as follows:
    <div class='snippet' id='javascript_115_9_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
let label_counter = 0;

        function new_label_number() {
            label_counter = label_counter + 1;
            return label-counter;
        }

        
        
        function make_label(name) {
            return name + stringify(new_label_number());
        }
</pre></div></div>
  </FOOTNOTE></div><div class='footnote'>
<a class='footnote-number' id='footnote-3' href='#footnote-link-3'>[3] </a><FOOTNOTE>We need machine operations to implement a data
    structure for representing compiled
    functions, analogous to the structure for
    compound
    functions
    described in section \ref{sec:eval-data-structures}:
    <div class='snippet' id='javascript_115_10_div'><div class='pre-prettyprint'><pre class='prettyprint no-eval'>
function make_compiled_procedure(entry, env) {
            return list("compiled_procedure", entry, env);
        }

        
        function is_compiled_procedure(proc) {
            return is_tagged_list(proc, "compiled_procedure");
        } 

        
        function compiled_procedure_entry(c_proc) {
            return head(tail(c_proc));
        }

        
        function compiled_procedure_env(c_proc) {
            return head(tail(tail(c_proc)));
        }
</pre></div></div>
    </FOOTNOTE></div>
</SUBSECTION><div class='nav'>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter5/section5/subsection1.html'>&lt; Previous</a>
</button><div style='flex-grow: 1;'></div>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a class='scroll-next' href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter5/section5/subsection3.html'>Next &gt;</a>
</button></div><div class='chapter_sign'>
5.5.2  Compiling Expressions</div>	<div class='next-page'></div></div>