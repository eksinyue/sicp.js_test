<div id='permalink-msg'>
<div class='screen'>
	<div class='alert alert-success'>
		<strong>Permalink copied!</strong>
	</div>
</div>
</div>

<div class='chapter-content'>
<div class='chapter-title'>
	<div class='permalink'>
		<a name='top' class='permalink'>5.2.1  The Machine Model</a>
	</div>
</div>
	<div class='chapter-text'>
		<div class='SUBSECTION'><SUBSECTION>

      

      <div class='permalink'>
<a name='p1' class='permalink'></a><p>
  The machine model generated by <kbd>make_machine</kbd> is represented as a
  function
  with local state using the message-passing techniques
  developed in chapter 3.  To build this model, <kbd>make_machine</kbd>
  begins by calling the
  function
  <kbd>make_new_machine</kbd> to construct
  the parts of the machine model that are common to all register
  machines.  This basic machine model constructed by <kbd>make_new_machine</kbd> is essentially a container for some registers and a
  stack, together with an execution mechanism that processes the controller
  instructions one by one.
      </p></div>

      <div class='permalink'>
<a name='p2' class='permalink'></a><p>
  <kbd>Make_machine</kbd> then extends this basic model (by sending it
  messages) to include the registers, operations, and controller of the
  particular machine being defined.  First it allocates a register in
  the new machine for each of the supplied register names and installs
  the designated operations in the machine.  Then it uses an 
  
  <EM>
    assembler</EM> (described below in section \ref{sec:assembler}) to
  transform the controller list into instructions for the new machine
  and installs these as the machine's instruction sequence.  <kbd>Make_machine</kbd> returns as its value the modified machine model.

  <div class='snippet' id='javascript_101_1_div'><div class='pre-prettyprint'><pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function make_machine(register_names, ops, controller_text) {
    const machine = make_new_machine();

    map(reg_name => machine("allocate_register")(reg_name), register_names);
    machine("install_operations")(ops);
    machine("install_instruction_sequence")(assemble(controller_text, machine));

    return machine;
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABAWwIYGsCmB9NEAWMYmAFAE6YDmMAzlJmdmKspjQDSJwAOHiECKGTgAbEQ2z0AHlACUiAN4AoRKv4I6KVASKZEAXi1YmmAO65thYiVkBuJSrVpu5KkxZ79APi07rAIlQxOAhUemwKajoGf1lXSndWWU5I2npGZlYaO0dVPCtSfyI6IJFsHgYw+DAaWJIebPs1XwKSIpqoUuxioRBoauwaTABHEExITDrUGiHkACNxEgEwIVFxRmkoTnzdWRzcxAooEDIkHeJ7AF8gA}{\usebox\lstbox}!*/
}

\end{JavaScriptClickable}
</pre>

</div></div>
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  Registers
      </h2></div>

      

      <div class='permalink'>
<a name='p3' class='permalink'></a><p>
  We will represent a register as a
  function
  with local state, as in
  chapter 3.  The
  function
  <kbd>make_register</kbd> creates a register that
  holds a value that can be accessed or changed:

  <div class='snippet' id='javascript_101_2_div'><div class='pre-prettyprint'><pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function make_register(name) {
    let contents = "*unassigned*";

    function dispatch(message) {
        if (message === "get") {
            return contents;

        } else {
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABAWwIYGsCmB9ATpgcxgGcpNcAKMVZTASkQG8AoRNxAG0ykQgTLBRiiALyIARACpwqYsRgEwmACaTxAbmat2oSLASJlJAA6ooEABYVac1AXpNt7djGCJrmW-dEix4+1DiDCzOoez4UCC4SHyCmILEmk6hAL6ImBzEmI5hYa7uNsR22b5+WYHBybmhEVFIAG6oHCAlAHxMvPzxQqKIjc2Y6ogpSdXOaRlZOWNh5LhwlIXFADQSAKpg6GBwAO5I+ACOLaQAXIgASgCiAOIAkgDKACqX50GaM2wpVexf41rOtWihhMZksmhSQA}{\usebox\lstbox}!*/
            if (message === "set") {
                return value => { contents = value; };

            } else {
                error(message, "Unknown request: REGISTER");
            }
        }
    }

    return dispatch;
}

\end{JavaScriptClickable}
</pre>

</div></div>
      </p></div>

      <div class='permalink'>
<a name='p4' class='permalink'></a><p>
  The following
  functions
  are used to access registers:

  <div class='snippet' id='javascript_101_3_div'><div class='pre-prettyprint'><pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function get_contents(register) {
    return register("get");
}

function set_contents(register, value) {
    return register("set")(value);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABAcwKZQPoQVVYoDOAFAE6rIwG4kCUiA3gFCIuJlQglJkVWolEARGiiCaAbkYBfRo1CRYCRAXRYceQqXKVqAGkQA3AIYAbEKjpNWbdJ27a+AwStE0ixsxclSgA}{\usebox\lstbox}
</pre>

</div></div>
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  The stack
      </h2></div>

      

      <div class='permalink'>
<a name='p5' class='permalink'></a><p>
  We can also represent a stack as a
  function
  with local state.  The
  function
  <kbd>make_stack</kbd> creates a stack whose local state consists
  of a list of the items on the stack.  A stack accepts requests to push an
  item onto the stack, to pop the top item off the stack
  and return it, and to initialize the stack to empty.

  <div class='snippet' id='javascript_101_4_div'><div class='pre-prettyprint'><pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function make_stack() {
    let stack = null;

    function push(x) { 
        stack = pair(x, stack); 
        return "done";
    }

\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABAWwIYGsCmB9AzlVCdACgEpEBvAKEVsQBtMpF9D1EBeRMEe+gbio06oSLASIADiFwALYgA9yFRMLp1WRTlNQwATooA0LAkVL9V69XqYg9SAEQATBJgeD1AXyHrR0eEiScJJklGpWMMCIxDC42Dx8xJropMrhVnSYenpwBg4AosiSUACeJmwAXIgACgDy1Q7mPhmInoiY9LiYYS1WEAj4iFDB2rKYqE5JpikevRrT2gQw9FNsTXN0NlB2SMOSsxneXs20fuJIMGAwsKj0MABemKHUvcnaCQLpm7b2iM6u7nC3nCZwCiCcsUkqCgEHkyEwuFwqAA5pg0r0tjsUAikajOBwuA5pHIHF8MgB+KQyWRkqxVeGIlHdAmEoKSUkbWiUtlkWnqek4pn4wmXa4wW4PNx8uiU0U3O6PXmcxBVLI5PIAVTA6DAcAA7kgbABHEAIqBVADKABUAIIAYQA0g5jAzcWiDq0TohMb8IbgoTDZIJPEA}{\usebox\lstbox}!*/
    function pop() {
        if (is_null(stack)) {
            error("Empty stack: POP");

        } else {
            const top = head(stack);
            stack = tail(stack);
            return top;
        }
    }

    function initialize() {
        stack = null;
        return "done";
    }

    function dispatch(message) {
        return message === "push"
            ? push
            : message === "pop"
            ? pop()
            : message === "initialize"
            ? initialize()
            : error("Unknown request: STACK", message);
    }

    return dispatch;
}

\end{JavaScriptClickable}
</pre>

</div></div>
      </p></div>

      <div class='permalink'>
<a name='p6' class='permalink'></a><p>
  The following
  functions
  are used to access stacks:

  <div class='snippet' id='javascript_101_5_div'><div class='pre-prettyprint'><pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function pop(stack) {
    return stack("pop");
}

function push(stack, value) {
    return stack("push")(value);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABABzsgFAZygQwgawEpEBvAKEUsQCcBTKEapbPfdAIlWXcIG4yAvmTKhIsBChCYAFllwEANIgBuOADYhaxclRr1GzeW05TpPdKo1b+AoA}{\usebox\lstbox}
</pre>

</div></div>
      </p></div>

      <div class='permalink'>
<a name='h1' class='permalink'></a><h2>
  The basic machine
      </h2></div>

      <div class='permalink'>
<a name='p7' class='permalink'></a><p>
  The <kbd>make_new_machine</kbd>
  function, shown in
  figure \ref{fig:make-new-machine}, constructs an object whose local
  state consists of a stack, an initially empty instruction sequence, a
  list of operations that initially contains an operation to 
  
  initialize
  the stack, and a 
  
  <EM>register table</EM> that initially contains two
  
  
  registers, named flag and pc
  
  (for <QUOTE>program counter</QUOTE>).
  The internal
  function
   adds new entries to the
  register table, and the internal
  function
  <kbd>lookup_register</kbd> looks
  up registers in the table.
      </p></div>

      <div class='permalink'>
<a name='p8' class='permalink'></a><p>
  The flag register is used to control branching in the simulated
  machine.  Test instructions set the contents of flag to
  the result of the test (true or false).  Branch instructions
  decide whether or not to branch by examining the contents of flag.
      </p></div>

      <div class='permalink'>
<a name='p9' class='permalink'></a><p>
  The pc register determines the sequencing of instructions as
  the machine runs.  This sequencing is implemented by the internal
  function
  execute.
  In the simulation model, each machine instruction is a data structure
  that includes a
  function
  of no arguments, called the 
  
  
  <EM>instruction
    execution
    function</EM>, such that calling this
  function
  simulates
  executing the instruction.  As the simulation runs, pc points to
  the place in the instruction sequence beginning with the next
  instruction to be executed.  
  
  Execute gets that instruction,
  executes it by calling the instruction execution
  function, and
  repeats this cycle until there are no more instructions to execute
  (i.e., until pc points to the end of the instruction sequence).

  <SPLIT>
    
    
      
\begin{figure}[H]
\centering
<pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function make_new_machine() {
    const pc = make_register("pc");
    const flag = make_register("flag");
    const stack = make_stack();
    let the_instruction_sequence = null;
    let the_ops = list(list("initialize_stack", () => stack("initialize")));
\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABAWwIYGsCmB9MmDu2aEAFjHgBQCUiA3gFCJOIQIDOUiADhIgLwoMOAE6YA5jA6ZhFAEQ9ZVANyNmrMB0TAANqjH9BWbKIlSZsnXsUrmLdpw6oI6A2iOPn1G822ZOUEhxyDmEQaHgwbDZMAEcQTEhMAzAQbW1vJl9-QOw4LjYDbUkoCiKOOXIYWFQigC8cD3RZABpEan4APkRGirAqmBqYesUqZVVMv0QTYulsKFQAI19C4tLV+QgW7ggqVrKSi10xLcsxUYytcHCERBrtOAhUKBFxGZkwVGRMGgZbWxhgG1UGw2A8KB8vq1pmY5otfDQ+IjEOAACaYYDkTAon7jP62aHPYSwpZJARcVAwGT7cGfTCtNwvUyEmlfUZQ14w+YksZ4pgAX0QmG00TouN5guEwjg71prVkAFlUrAuNoAJ6INEYvAoqYcwkALkQ1jFzD5JqYoigIGESFkBNmdweTyxsguZtsoEgsBu9zg6BAXGMeukLO+ovF6k0ADcagZgaCIKH2UzZlz4Rd8X5rUgY9p+EjUejMSjzX8APwSqUyyFGgCqYHQYDg+CQ9uE+sUpdshsCqBRFHmMG0FFz51x7uYnuuSEwAA9MBAQM92r9eZHOMEoAUBGI-Nh1M8wFuKDwebyAW1JLhUsPN2xRuHxcxLdmjSiEJhXaWBUKRaun3YGicFwUq8AIm6hNO2BzguS4RNgIFgr2-Z3uciBdswiGJso6EARaWY2oK86LsuZ54hO-K4lO3pICikjklApAUF8IJ6GG-5-C+hEsWwbH5gIsiOMIUCyBheIVu0fBdLQ3R7geCTHjwrQBEEQGQTRUSxPEiRkXhelcTOxFLpgXh6WZiAUU+ho8XxiICZudzYBBYQadEcQJBAn5ieWskxJ0dCICpTlqS58FudpnkGG5SgWd51mYKxu78UajqPM8QYpsIonmUwFapc6GVvHFKAJbxSV2Uau5QIVZjZTlFa+v6gZtsVNnlUisgOWkuRcNITwRGwdXmRWeTbtJgU5KNcZcL1YD9kFo2tKNOGWeK8WJaSHWNENZkVo0rWlbZHV5H1NGDd5tgVgt+TFdIVbMYdu5yvWjbNq2WkJVAhrygAggAwgAEgAkgAcgAosatiWQZGr0U8pAqHyQA}{\usebox\lstbox}!*/
    let register_table = list(list("pc", pc), list("flag", flag));
    function allocate_register(name) {
        if (assoc(name, register_table) === undefined) {
            register_table = pair(list(name, make_register(name)), register_table);
        } else {
            error(name, "Multiply defined register: ");
        }
        return "register_allocated";
    }
    function lookup_register(name) {
        const val = assoc(name, register_table);
        return val === undefined
            ? error(name, "Unknown register:")
            : head(tail(val));
    }
    function execute() {
        const insts = get_contents(pc);
        if (is_null(insts)) {
            return "done";
        } else {
            const proc = instruction_execution_proc(head(insts)); 
            proc(); 
            return execute();
        }
    }
    function dispatch(message) {
        return message === "start"
                ? () => { set_contents(pc, the_instruction_sequence);
                          return execute();                          }
            : message === "install_instruction_sequence"
                ? seq => { the_instruction_sequence = seq; }
            : message === "allocate_register"
                ? allocate_register
            : message === "get_register"
                ? lookup_register
            : message === "install_operations"
                ? ops => { the_ops = append(the_ops, ops); }
            : message === "stack"
                ? stack
            : message === "operations"
                ? the_ops
            : error(message, "Unknown request: MACHINE");
    }
    return dispatch;
}

\end{JavaScriptClickable}
</pre>

\caption{The <kbd>make_new_machine</kbd> function,
  which implements the basic machine model.}
\label{fig:make-new-machine}
\end{figure}

    
  </SPLIT>
      </p></div>

      <div class='permalink'>
<a name='p10' class='permalink'></a><p>
  As part of its operation, each instruction execution
  function
  modifies pc to indicate the next instruction to be executed.
  Branch and <kbd>go_to</kbd> instructions change pc to point to
  the new destination.  All other instructions simply advance pc,
  making it point to the next instruction in the sequence.  Observe that
  each call to execute calls execute again, but this does
  not produce an infinite loop because running the instruction execution
  function
  changes the contents of pc.
      </p></div>

      <div class='permalink'>
<a name='p11' class='permalink'></a><p>
  <kbd>Make_new_machine</kbd> returns a
  dispatch
  function
  that implements message-passing
  access to the internal state.  Notice that starting the machine is
  accomplished by setting pc to the beginning of the instruction
  sequence and calling execute.
      </p></div>

      <div class='permalink'>
<a name='p12' class='permalink'></a><p>
  For convenience, we provide an alternate procedural interface to a
  machine's start operation,
  as well as
  functions
  to set and examine register contents,
  as specified at the beginning of section \ref{sec:simulator}:

  <div class='snippet' id='javascript_101_6_div'><div class='pre-prettyprint'><pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function start(machine) {
    return machine("start")();
}

function get_register_contents(machine, register_name) {
    return get_contents(get_register(machine, register_name));
}

\end{JavaScriptClickable}
\end{lrbox}
\begin{JavaScriptClickable}
/*!\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABAZygQwE5QBQFs0QAWMYApgJSIDeAUIvYhqVCBkvkSadgESqZQe5bOQDcNAL40aoSLASIA5swD6TRTFSkMKiAiikwUZHgLEyAGkakNWnWDS4K1OgyYs2S1XqOHj2ZSg1G00DDFNOS2tbMJUHJ3IxSWlZaHgkZFV1UO1dfT8TDnNSK2y7OMcSxAA3NAAbEGdaBhRvfKMTQOCY7Qji0pDy+IorWoaKcRb3ViQeABMEUh5xCSA}{\usebox\lstbox}!*/
function set_register_contents(machine, register_name, value) {
    set_contents(get_register(machine, register_name), value);
    return "done";
}

\end{JavaScriptClickable}
</pre>

</div></div>
      </p></div>

      <div class='permalink'>
<a name='p13' class='permalink'></a><p>
  These
  functions
  (and many
  functions
  in sections \ref{sec:assembler}
  and \ref{sec:ex-proc}) use the following to look up the register with a
  given name in a given machine:
  <div class='snippet' id='javascript_101_7_div'><div class='pre-prettyprint'><pre class='prettyprint' title='Evaluate Javascript expression'
\begin{lrbox}{\lstbox}
\begin{JavaScriptClickable}
function get_register(machine, reg_name) {
    return machine("get_register")(reg_name);
}
\end{JavaScriptClickable}
\end{lrbox}

\href{https://sourceacademy.nus.edu.sg/playground#chap=5&prgrm=GYVwdgxgLglg9mABAcwKZQPoCdXJgZylSwAoBbAQwgAsYxUAaRHZDMCs1ASkQG8AoREOboQWJJRp1UJAERpMLAkSyyuJFmw7cA3PwC+QA}{\usebox\lstbox}
</pre>

</div></div>
      </p></div>

    
</SUBSECTION><div class='nav'>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter5/section2/section2.html'>&lt; Previous</a>
</button><div style='flex-grow: 1;'></div>
<button type='button' class='btn btn-secondary' style='background-color: #fff;'>
<a class='scroll-next' href='/Users/xinyue/Documents/nus/y1s2/CP3108/sicp.js_test/html/chapter5/section2/subsection2.html'>Next &gt;</a>
</button></div><div class='chapter_sign'>
5.2.1  The Machine Model</div>	<div class='next-page'></div></div>